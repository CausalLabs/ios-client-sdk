// DO NOT EDIT -- file automatically generated by CausalLabsSDK.
// https://www.causallabs.io

// swiftformat:disable all
// swiftlint:disable all

import CausalLabsSDK
import Foundation
import SwiftUI

private func encodeObject<T: Codable>(_ object: T) throws -> JSONObject {
    let data = try JSONEncoder().encode(object)
    let jsonObject = try JSONSerialization.jsonObject(with: data) as? JSONObject
    return jsonObject ?? [:]
}

private func decodeObject<T: Codable>(from jsonObject: JSONObject, to type: T.Type) throws -> T {
    let data = try JSONSerialization.data(withJSONObject: jsonObject)
    return try JSONDecoder().decode(T.self, from: data)
}

private struct _IdObject<T: Codable>: Codable {
    var name: String
    var args: T
}

private func generateIdFrom<T: Codable>(name: String, args: T) -> String {
    let encoder = JSONEncoder()
    encoder.outputFormatting = [.sortedKeys]

    let idObject = _IdObject(name: name, args: args)
    if let jsonData = try? encoder.encode(idObject),
       let id = String(data: jsonData, encoding: .utf8) {
        return id
    }
    return "invalidFeatureId"
}


// MARK: - ImpressionTime

struct ImpressionTime: Hashable, Codable {
    var impressionId: String

    var impressionTime: Int

}

// MARK: - Session

private struct _SessionOutputs: Codable, Hashable {
}

private struct _SessionArgs: Codable, Hashable {
    var deviceId: String?
}

private struct _SessionKeys: Codable, Hashable {
    var deviceId: String?
}


struct Session: SessionProtocol {
    var persistentId: DeviceId? {
        self.deviceId
    }

    // MARK: Arguments

    private var _args: _SessionArgs

    var deviceId: String? {
        _args.deviceId
    }

    // MARK: Outputs

    private var _outputs: _SessionOutputs = _SessionOutputs()


    init(deviceId: String) {
        self._args = _SessionArgs(deviceId:deviceId)
    }

    var id: SessionId {
        generateIdFrom(name: "session", args: self._args)
    }

    func keys() throws -> JSONObject {
        let keys = _SessionKeys(deviceId:_args.deviceId)
        return try encodeObject(keys)
    }

    func args() throws -> JSONObject {
        try encodeObject(self._args)
    }

    mutating func updateFrom(json: JSONObject) throws {
        self._outputs = try decodeObject(from: json, to: _SessionOutputs.self)
    }
}

extension Session {
    private init(_args: _SessionArgs) {
        self._args = _args
    }

    static func fromDeviceId(_ deviceId: String) -> Session {
        Session(_args: _SessionArgs(deviceId: deviceId))
    }

}

// MARK: Session Events

extension Session {
    /// Details all possible session events
    enum Event: SessionEventProvider {

        var eventDetails: any SessionEvent {
            switch self {
            }
        }
    }
}

extension CausalClientProtocol {
    /// Signal a session event occurred to the impression service.
    ///
    /// An alternative to `signalAndWait(sessionEvent:)` that is "fire-and-forget" and ignores errors.
    ///
    /// - Parameter sessionEvent: The session event that occurred.    
    func signal(sessionEvent: Session.Event) {
        signal(sessionEvent: sessionEvent.eventDetails)
    }

    /// Signal a session event occurred to the impression service.
    ///
    /// - Parameter sessionEvent: The session event that occurred.
    func signalAndWait(sessionEvent: Session.Event) async throws {
        try await signalAndWait(sessionEvent: sessionEvent.eventDetails)
    }    
}


// MARK: - RatingBox



/// Wraps a rating box that we can put on various product pages
/// to collect ratings from our users
final class RatingBox: FeatureProtocol {
    struct Outputs: FeatureOutputsProtocol, Codable, Hashable {
        /// The text next to the stars that prompts the visitor to rate the product
        let callToAction: String

        /// The button text for the user submit a review.
        let actionButton: String

        let _impressionId: ImpressionId?

        fileprivate init(callToAction: String = "Rate this product!", actionButton: String = "Send Review", _impressionId: ImpressionId? = nil) {
            self.callToAction = callToAction
            self.actionButton = actionButton
            self._impressionId = _impressionId
        }

        fileprivate func with(impressionId: ImpressionId) -> Outputs {
            Outputs(
                callToAction: self.callToAction,
                actionButton: self.actionButton,
                _impressionId: impressionId
            )
        }

        static let defaultValues = Outputs()
    }

    struct Args: Codable, Hashable {
        /// The product that we are collecting ratings for
        let product: String

    }

    static let name = "RatingBox"

    /// Feature arguments
    private(set) var args: Args

    /// The status of the feature
    private(set) var status: FeatureStatus<Outputs> = .unrequested

    // MARK: Init

    init(product: String) {
        self.args = Args(product: product)
    }

    fileprivate init(args: Args) {
        self.args = args
    }

    // MARK: FeatureProtocol

    var id: FeatureId {
        generateIdFrom(name: "RatingBox", args: self.args)
    }

    func update(request: FeatureUpdateRequest) throws {
        switch request {
        case .off:
             self.status = .off

        case let .on(outputJson, impressionId):
            let cachedOutputs = try decodeObject(from: outputJson, to: Outputs.self)

            if let impressionId {
                let outputsWithImpressionId = cachedOutputs.with(impressionId: impressionId)
                 self.status = .on(outputs: outputsWithImpressionId)
            } else {
                 self.status = .on(outputs: cachedOutputs)
            }
        }
    }

    func event(_ event: Event) -> FeatureEventPayload? {
        guard case let .on(outputs) = status, let impressionId = outputs._impressionId else {
            // Attempting to generate an event for a feature that is not active or doesn't have an associated impression id.
            return nil
        }

        return (event.eventDetails, impressionId)
    }

    func clone() -> RatingBox {
        let copy = RatingBox(args: self.args)
        copy.status = self.status
        return copy
    }
}

extension RatingBox: Equatable {
    public static func == (left: RatingBox, right: RatingBox) -> Bool {
        left.args == right.args && left.status == right.status
    }
}

// MARK: RatingBox Events

extension RatingBox {
    /// Details all possible session events
    enum Event: FeatureEventProvider {

        /// Occurs each time a rating is collected
        /// - Parameter stars: 
        case rating(stars: Int)

        var eventDetails: any FeatureEvent {
            switch self {
                case .rating(let stars):
                    return Rating(stars: stars)
            }
        }

        /// Occurs each time a rating is collected
        struct Rating: FeatureEvent {
            /// The name of the feature for which this event is associated.
            public static let featureName = "RatingBox"

            /// The name of this event.
            public static let name = "Rating"

            var stars: Int

            func serialized() throws -> JSONObject {
                let json = try encodeObject(self)
                return json
            }
        }
    }
}

// MARK: - RatingBox View Model

final class RatingBoxViewModel: ObservableObject, FeatureViewModel {

    /// Describes error states for this view model.
    enum ViewModelError: Swift.Error {
        /// Indicates that the `feature` was not successfully requested.
        case missingFeature

        /// Indicates that the `FeatureEventPayload` was not successfully generated.
        /// This normally happens if the feature is `off` or hasn't been successfully 
        /// requested yet.
        case missingFeatureEvent
    }

    enum State: Equatable {
        /// The requested feature is not active and should not be rendered.
        case off

        /// The requested feature is currently being fetched.
        case loading

        /// The requested feature has been loaded, is active, and is ready to be rendered.
        /// - Parameter outputs: The loaded feature outputs.
        case on(outputs: RatingBox.Outputs)
    }

    private var feature: RatingBox?
    @Published private(set) var state: State = .loading

    private let client: CausalClientProtocol
    private let featureArgs: RatingBox.Args
    private let impressionId: ImpressionId

    // MARK: Init

    init(client: CausalClientProtocol = CausalClient.shared, product: String, impressionId: ImpressionId = .newId()) {
        self.client = client
        self.featureArgs = RatingBox.Args(
            product: product
        )
        self.impressionId = impressionId
    }

    // MARK: Feature request

    @MainActor
    func requestFeature() async {
        let _feature = RatingBox(
            product: self.featureArgs.product
        )

        self.state = .loading
        let result = await client.requestFeature(_feature, impressionId: self.impressionId)

        if result == nil {
            self.feature = _feature
            switch _feature.status {
                case let .on(outputs):
                    self.state = .on(outputs: outputs)
                case .off:
                    self.state = .off
                case .unrequested:
                    self.state = .loading
            }            
        } else {
            // In the event of an error requesting the feature show default values.
            // Note: Signaled events from this render will be dropped.
            self.state = .on(outputs: RatingBox.Outputs.defaultValues)
        }
    }

    // MARK: Events

    func signal(event: RatingBox.Event, onError: ((Error) -> Void)? = nil) {
        guard let feature else { 
            onError?(ViewModelError.missingFeature)
            return
        }

        guard let featureEvent = feature.event(event) else {
            onError?(ViewModelError.missingFeatureEvent)
            return            
        }

        Task {
            do {
                try await client.signalAndWait(featureEvent: featureEvent)
            } catch {
                onError?(error)
            }
        }
    }
}

// MARK: - ProductInfo



/// An empty feature to use only as a kill switch
final class ProductInfo: FeatureProtocol {
    struct Outputs: FeatureOutputsProtocol, Codable, Hashable {
        let _impressionId: ImpressionId?

        fileprivate init(_impressionId: ImpressionId? = nil) {
            self._impressionId = _impressionId
        }

        fileprivate func with(impressionId: ImpressionId) -> Outputs {
            Outputs(
                _impressionId: impressionId
            )
        }

        static let defaultValues = Outputs()
    }

    struct Args: Codable, Hashable {
    }

    static let name = "ProductInfo"

    /// Feature arguments
    private(set) var args: Args

    /// The status of the feature
    private(set) var status: FeatureStatus<Outputs> = .unrequested

    // MARK: Init

    init() {
        self.args = Args()
    }

    fileprivate init(args: Args) {
        self.args = args
    }

    // MARK: FeatureProtocol

    var id: FeatureId {
        generateIdFrom(name: "ProductInfo", args: self.args)
    }

    func update(request: FeatureUpdateRequest) throws {
        switch request {
        case .off:
             self.status = .off

        case let .on(outputJson, impressionId):
            let cachedOutputs = try decodeObject(from: outputJson, to: Outputs.self)

            if let impressionId {
                let outputsWithImpressionId = cachedOutputs.with(impressionId: impressionId)
                 self.status = .on(outputs: outputsWithImpressionId)
            } else {
                 self.status = .on(outputs: cachedOutputs)
            }
        }
    }

    func event(_ event: Event) -> FeatureEventPayload? {
        guard case let .on(outputs) = status, let impressionId = outputs._impressionId else {
            // Attempting to generate an event for a feature that is not active or doesn't have an associated impression id.
            return nil
        }

        return (event.eventDetails, impressionId)
    }

    func clone() -> ProductInfo {
        let copy = ProductInfo(args: self.args)
        copy.status = self.status
        return copy
    }
}

extension ProductInfo: Equatable {
    public static func == (left: ProductInfo, right: ProductInfo) -> Bool {
        left.args == right.args && left.status == right.status
    }
}

// MARK: ProductInfo Events

extension ProductInfo {
    /// Details all possible session events
    enum Event: FeatureEventProvider {

        var eventDetails: any FeatureEvent {
            switch self {
            }
        }
    }
}

// MARK: - ProductInfo View Model

final class ProductInfoViewModel: ObservableObject, FeatureViewModel {

    /// Describes error states for this view model.
    enum ViewModelError: Swift.Error {
        /// Indicates that the `feature` was not successfully requested.
        case missingFeature

        /// Indicates that the `FeatureEventPayload` was not successfully generated.
        /// This normally happens if the feature is `off` or hasn't been successfully 
        /// requested yet.
        case missingFeatureEvent
    }

    enum State: Equatable {
        /// The requested feature is not active and should not be rendered.
        case off

        /// The requested feature is currently being fetched.
        case loading

        /// The requested feature has been loaded, is active, and is ready to be rendered.
        /// - Parameter outputs: The loaded feature outputs.
        case on(outputs: ProductInfo.Outputs)
    }

    private var feature: ProductInfo?
    @Published private(set) var state: State = .loading

    private let client: CausalClientProtocol
    private let featureArgs: ProductInfo.Args
    private let impressionId: ImpressionId

    // MARK: Init

    init(client: CausalClientProtocol = CausalClient.shared, impressionId: ImpressionId = .newId()) {
        self.client = client
        self.featureArgs = ProductInfo.Args(
        )
        self.impressionId = impressionId
    }

    // MARK: Feature request

    @MainActor
    func requestFeature() async {
        let _feature = ProductInfo(
        )

        self.state = .loading
        let result = await client.requestFeature(_feature, impressionId: self.impressionId)

        if result == nil {
            self.feature = _feature
            switch _feature.status {
                case let .on(outputs):
                    self.state = .on(outputs: outputs)
                case .off:
                    self.state = .off
                case .unrequested:
                    self.state = .loading
            }            
        } else {
            // In the event of an error requesting the feature show default values.
            // Note: Signaled events from this render will be dropped.
            self.state = .on(outputs: ProductInfo.Outputs.defaultValues)
        }
    }

    // MARK: Events

    func signal(event: ProductInfo.Event, onError: ((Error) -> Void)? = nil) {
        guard let feature else { 
            onError?(ViewModelError.missingFeature)
            return
        }

        guard let featureEvent = feature.event(event) else {
            onError?(ViewModelError.missingFeatureEvent)
            return            
        }

        Task {
            do {
                try await client.signalAndWait(featureEvent: featureEvent)
            } catch {
                onError?(error)
            }
        }
    }
}

// MARK: - Feature2



/// Another feature just for demonstration purposes
final class Feature2: FeatureProtocol {
    struct Outputs: FeatureOutputsProtocol, Codable, Hashable {
        /// Example output
        let exampleOutput: String

        let _impressionId: ImpressionId?

        fileprivate init(exampleOutput: String = "Example output", _impressionId: ImpressionId? = nil) {
            self.exampleOutput = exampleOutput
            self._impressionId = _impressionId
        }

        fileprivate func with(impressionId: ImpressionId) -> Outputs {
            Outputs(
                exampleOutput: self.exampleOutput,
                _impressionId: impressionId
            )
        }

        static let defaultValues = Outputs()
    }

    struct Args: Codable, Hashable {
        /// Example args
        let exampleArg: String

    }

    static let name = "Feature2"

    /// Feature arguments
    private(set) var args: Args

    /// The status of the feature
    private(set) var status: FeatureStatus<Outputs> = .unrequested

    // MARK: Init

    init(exampleArg: String) {
        self.args = Args(exampleArg: exampleArg)
    }

    fileprivate init(args: Args) {
        self.args = args
    }

    // MARK: FeatureProtocol

    var id: FeatureId {
        generateIdFrom(name: "Feature2", args: self.args)
    }

    func update(request: FeatureUpdateRequest) throws {
        switch request {
        case .off:
             self.status = .off

        case let .on(outputJson, impressionId):
            let cachedOutputs = try decodeObject(from: outputJson, to: Outputs.self)

            if let impressionId {
                let outputsWithImpressionId = cachedOutputs.with(impressionId: impressionId)
                 self.status = .on(outputs: outputsWithImpressionId)
            } else {
                 self.status = .on(outputs: cachedOutputs)
            }
        }
    }

    func event(_ event: Event) -> FeatureEventPayload? {
        guard case let .on(outputs) = status, let impressionId = outputs._impressionId else {
            // Attempting to generate an event for a feature that is not active or doesn't have an associated impression id.
            return nil
        }

        return (event.eventDetails, impressionId)
    }

    func clone() -> Feature2 {
        let copy = Feature2(args: self.args)
        copy.status = self.status
        return copy
    }
}

extension Feature2: Equatable {
    public static func == (left: Feature2, right: Feature2) -> Bool {
        left.args == right.args && left.status == right.status
    }
}

// MARK: Feature2 Events

extension Feature2 {
    /// Details all possible session events
    enum Event: FeatureEventProvider {

        /// Example event
        /// - Parameter data: 
        case exampleEvent(data: String)

        var eventDetails: any FeatureEvent {
            switch self {
                case .exampleEvent(let data):
                    return ExampleEvent(data: data)
            }
        }

        /// Example event
        struct ExampleEvent: FeatureEvent {
            /// The name of the feature for which this event is associated.
            public static let featureName = "Feature2"

            /// The name of this event.
            public static let name = "ExampleEvent"

            var data: String

            func serialized() throws -> JSONObject {
                let json = try encodeObject(self)
                return json
            }
        }
    }
}

// MARK: - Feature2 View Model

final class Feature2ViewModel: ObservableObject, FeatureViewModel {

    /// Describes error states for this view model.
    enum ViewModelError: Swift.Error {
        /// Indicates that the `feature` was not successfully requested.
        case missingFeature

        /// Indicates that the `FeatureEventPayload` was not successfully generated.
        /// This normally happens if the feature is `off` or hasn't been successfully 
        /// requested yet.
        case missingFeatureEvent
    }

    enum State: Equatable {
        /// The requested feature is not active and should not be rendered.
        case off

        /// The requested feature is currently being fetched.
        case loading

        /// The requested feature has been loaded, is active, and is ready to be rendered.
        /// - Parameter outputs: The loaded feature outputs.
        case on(outputs: Feature2.Outputs)
    }

    private var feature: Feature2?
    @Published private(set) var state: State = .loading

    private let client: CausalClientProtocol
    private let featureArgs: Feature2.Args
    private let impressionId: ImpressionId

    // MARK: Init

    init(client: CausalClientProtocol = CausalClient.shared, exampleArg: String, impressionId: ImpressionId = .newId()) {
        self.client = client
        self.featureArgs = Feature2.Args(
            exampleArg: exampleArg
        )
        self.impressionId = impressionId
    }

    // MARK: Feature request

    @MainActor
    func requestFeature() async {
        let _feature = Feature2(
            exampleArg: self.featureArgs.exampleArg
        )

        self.state = .loading
        let result = await client.requestFeature(_feature, impressionId: self.impressionId)

        if result == nil {
            self.feature = _feature
            switch _feature.status {
                case let .on(outputs):
                    self.state = .on(outputs: outputs)
                case .off:
                    self.state = .off
                case .unrequested:
                    self.state = .loading
            }            
        } else {
            // In the event of an error requesting the feature show default values.
            // Note: Signaled events from this render will be dropped.
            self.state = .on(outputs: Feature2.Outputs.defaultValues)
        }
    }

    // MARK: Events

    func signal(event: Feature2.Event, onError: ((Error) -> Void)? = nil) {
        guard let feature else { 
            onError?(ViewModelError.missingFeature)
            return
        }

        guard let featureEvent = feature.event(event) else {
            onError?(ViewModelError.missingFeatureEvent)
            return            
        }

        Task {
            do {
                try await client.signalAndWait(featureEvent: featureEvent)
            } catch {
                onError?(error)
            }
        }
    }
}


// swiftformat:enable all
// swiftlint:enable all
