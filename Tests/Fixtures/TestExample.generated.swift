// DO NOT EDIT -- file automatically generated by CausalLabsSDK.
// https://www.causallabs.io

// swiftformat:disable all
// swiftlint:disable all

import CausalLabsSDK
import Foundation
import SwiftUI

private func encodeObject<T: Codable>(_ object: T) throws -> JSONObject {
    let data = try JSONEncoder().encode(object)
    let jsonObject = try JSONSerialization.jsonObject(with: data) as? JSONObject
    return jsonObject ?? [:]
}

private func decodeObject<T: Codable>(from jsonObject: JSONObject, to type: T.Type) throws -> T {
    let data = try JSONSerialization.data(withJSONObject: jsonObject)
    return try JSONDecoder().decode(T.self, from: data)
}

private struct _IdObject<T: Codable>: Codable {
    var name: String
    var args: T
}

private func generateIdFrom<T: Codable>(name: String, args: T) -> String {
    let encoder = JSONEncoder()
    encoder.outputFormatting = [.sortedKeys]

    let idObject = _IdObject(name: name, args: args)
    if let jsonData = try? encoder.encode(idObject),
       let id = String(data: jsonData, encoding: .utf8) {
        return id
    }
    return "invalidFeatureId"
}

// MARK: - Currency

/// Class that is used to represent a currency amount
/// @deprecated Do not use this. Money is evil.
@available(*, deprecated, message: "Do not use this. Money is evil.")
enum Currency: String, Hashable, Codable {
    /// United States Dollars
    /// @deprecated Unite socialist democrats!!
    @available(*, deprecated, message: "Unite socialist democrats!!")
    case USD
    /// Euros
    case EUR
}

// MARK: - Color

/// A color enum.
enum Color: String, Hashable, Codable {
    case PRIMARY
    case SECONDARY
    case WARNING
    case ERROR
}


// MARK: - ImpressionTime

struct ImpressionTime: Hashable, Codable {
    var impressionId: String

    var impressionTime: Int

}
// MARK: - Price

/// Defines a product price.
struct Price: Hashable, Codable {
    /// The currency type.
    /// @deprecated deprecate
    @available(*, deprecated, message: "deprecate")
    var currency: Currency

    /// The amount.
    var amount: Double

}
// MARK: - CustomerData

struct CustomerData: Hashable, Codable {
    var zip: String

    var productViews: Int

    var lastViews: [String]

}
// MARK: - NestedObject

struct NestedObject: Hashable, Codable {
    var float1: Double

    var int1: Int

}
// MARK: - TopLevelObject

struct TopLevelObject: Hashable, Codable {
    var float1: Double

    var float2: Double?

    var enum1: Color

    var enum2: Color?

    var string1: String

    var string2: String?

    var int1: Int

    var int2: Int?

    var nested1: NestedObject

    var nested2: NestedObject?

}
// MARK: - DumbObject

struct DumbObject: Hashable, Codable {
    var a: Int

}

// MARK: - Session

private struct _SessionOutputs: Codable, Hashable {
}

private struct _SessionArgs: Codable, Hashable {
    var deviceId: String?
    var arrivalKey: String?
    var userId: String?
    var required: Int?
    var optional: String?
    var withDefault: String?
}

private struct _SessionKeys: Codable, Hashable {
    var deviceId: String?
    var arrivalKey: String?
}


struct Session: SessionProtocol {
    var persistentId: DeviceId? {
        self.deviceId
    }

    // MARK: Arguments

    private var _args: _SessionArgs

    var deviceId: String? {
        _args.deviceId
    }

    var arrivalKey: String? {
        _args.arrivalKey
    }

    var userId: String? {
        _args.userId
    }

    var required: Int? {
        _args.required
    }

    var optional: String? {
        _args.optional
    }

    var withDefault: String? {
        _args.withDefault
    }

    // MARK: Outputs

    private var _outputs: _SessionOutputs = _SessionOutputs()


    init(deviceId: String, arrivalKey: String? = nil, userId: String? = nil, required: Int, optional: String? = nil, withDefault: String? = "a default value") {
        self._args = _SessionArgs(deviceId:deviceId, arrivalKey:arrivalKey, userId:userId, required:required, optional:optional, withDefault:withDefault)
    }

    var id: SessionId {
        generateIdFrom(name: "session", args: self._args)
    }

    func keys() throws -> JSONObject {
        let keys = _SessionKeys(deviceId:_args.deviceId, arrivalKey:_args.arrivalKey)
        return try encodeObject(keys)
    }

    func args() throws -> JSONObject {
        try encodeObject(self._args)
    }

    mutating func updateFrom(json: JSONObject) throws {
        self._outputs = try decodeObject(from: json, to: _SessionOutputs.self)
    }
}

extension Session {
    private init(_args: _SessionArgs) {
        self._args = _args
    }

    static func fromDeviceId(_ deviceId: String) -> Session {
        Session(_args: _SessionArgs(deviceId: deviceId))
    }

    static func fromArrivalKey(_ arrivalKey: String) -> Session {
        Session(_args: _SessionArgs(arrivalKey: arrivalKey))
    }

}

// MARK: Session Events

extension Session {
    /// Details all possible session events
    enum Event: SessionEventProvider {

        case trackUser(timestamp: Int)

        /// The user has added a productid to the cart
        /// - Parameter productid: 
        /// - Parameter price: 
        case addToCart(productid: String, price: Price? = nil)

        /// 
        /// @deprecated for some reason
        /// - Parameter productid: 
        /// - Parameter price: 
        @available(*, deprecated, message: "for some reason")
        case addToCart2(productid: String, price: Price? = nil)

        case eventZ(anInt: Int? = 11)

        var eventDetails: any SessionEvent {
            switch self {
                case .trackUser(let timestamp):
                    return TrackUser(timestamp: timestamp)
                case .addToCart(let productid, let price):
                    return AddToCart(productid: productid, price: price)
                case .addToCart2(let productid, let price):
                    return AddToCart2(productid: productid, price: price)
                case .eventZ(let anInt):
                    return EventZ(anInt: anInt)
            }
        }

        struct TrackUser: SessionEvent {
            static let featureName = "session"

            /// The name of this event.
            static let name = "TrackUser"

            // MARK: Inputs

            var timestamp: Int

            func serialized() throws -> JSONObject {
                let json = try encodeObject(self)
                return json
            }
        }

        /// The user has added a productid to the cart
        struct AddToCart: SessionEvent {
            static let featureName = "session"

            /// The name of this event.
            static let name = "AddToCart"

            // MARK: Inputs

            var productid: String

            var price: Price?

            func serialized() throws -> JSONObject {
                let json = try encodeObject(self)
                return json
            }
        }

        /// 
        /// @deprecated for some reason
        @available(*, deprecated, message: "for some reason")
        struct AddToCart2: SessionEvent {
            static let featureName = "session"

            /// The name of this event.
            static let name = "AddToCart2"

            // MARK: Inputs

            var productid: String

            var price: Price?

            func serialized() throws -> JSONObject {
                let json = try encodeObject(self)
                return json
            }
        }

        struct EventZ: SessionEvent {
            static let featureName = "session"

            /// The name of this event.
            static let name = "EventZ"

            // MARK: Inputs

            var anInt: Int?

            func serialized() throws -> JSONObject {
                let json = try encodeObject(self)
                return json
            }
        }
    }
}

extension CausalClientProtocol {
    /// Signal a session event occurred to the impression service.
    ///
    /// An alternative to `signalAndWait(sessionEvent:)` that is "fire-and-forget" and ignores errors.
    ///
    /// - Parameter sessionEvent: The session event that occurred.    
    func signal(sessionEvent: Session.Event) {
        signal(sessionEvent: sessionEvent.eventDetails)
    }

    /// Signal a session event occurred to the impression service.
    ///
    /// - Parameter sessionEvent: The session event that occurred.
    func signalAndWait(sessionEvent: Session.Event) async throws {
        try await signalAndWait(sessionEvent: sessionEvent.eventDetails)
    }    
}


// MARK: - RatingBox



/// Describes a rating box that we can put on various product pages
/// to collect ratings from our users.
final class RatingBox: FeatureProtocol {
    struct Outputs: FeatureOutputsProtocol, Codable, Hashable {
        /// The prompts for the user to rate the product.
        let callToAction: String

        /// The button text for the user submit a review.
        let actionButton: String

        let _impressionId: ImpressionId?

        fileprivate init(callToAction: String = "Rate this product!", actionButton: String = "Send Review", _impressionId: ImpressionId? = nil) {
            self.callToAction = callToAction
            self.actionButton = actionButton
            self._impressionId = _impressionId
        }

        fileprivate func with(impressionId: ImpressionId) -> Outputs {
            Outputs(
                callToAction: self.callToAction,
                actionButton: self.actionButton,
                _impressionId: impressionId
            )
        }

        static let defaultValues = Outputs()
    }

    struct Args: Codable, Hashable {
        /// The product for which we are collecting ratings.
        let productName: String

        /// The price of the product for which we are collecting ratings.
        let productPrice: Double

        /// The description of the product, if any.
        let productDescription: String?

    }

    static let name = "RatingBox"

    /// Feature arguments
    private(set) var args: Args

    /// The status of the feature
    private(set) var status: FeatureStatus<Outputs> = .unrequested

    // MARK: Init

    init(productName: String, productPrice: Double, productDescription: String? = nil) {
        self.args = Args(productName: productName, productPrice: productPrice, productDescription: productDescription)
    }

    fileprivate init(args: Args) {
        self.args = args
    }

    // MARK: FeatureProtocol

    var id: FeatureId {
        generateIdFrom(name: "RatingBox", args: self.args)
    }

    func update(request: FeatureUpdateRequest) throws {
        switch request {
        case .off:
             self.status = .off

        case let .on(outputJson, impressionId):
            let cachedOutputs = try decodeObject(from: outputJson, to: Outputs.self)

            if let impressionId {
                let outputsWithImpressionId = cachedOutputs.with(impressionId: impressionId)
                 self.status = .on(outputs: outputsWithImpressionId)
            } else {
                 self.status = .on(outputs: cachedOutputs)
            }
        }
    }

    func event(_ event: Event) -> FeatureEventPayload? {
        guard case let .on(outputs) = status, let impressionId = outputs._impressionId else {
            // Attempting to generate an event for a feature that is not active or doesn't have an associated impression id.
            return nil
        }

        return (event.eventDetails, impressionId)
    }

    func clone() -> RatingBox {
        let copy = RatingBox(args: self.args)
        copy.status = self.status
        return copy
    }
}

extension RatingBox: Equatable {
    public static func == (left: RatingBox, right: RatingBox) -> Bool {
        left.args == right.args && left.status == right.status
    }
}

// MARK: RatingBox Events

extension RatingBox {
    /// Details all possible session events
    enum Event: FeatureEventProvider {

        /// Occurs each time a rating is collected.
        /// - Parameter stars: The rating value from the user.
        case rating(stars: Int)

        var eventDetails: any FeatureEvent {
            switch self {
                case .rating(let stars):
                    return Rating(stars: stars)
            }
        }

        /// Occurs each time a rating is collected.
        struct Rating: FeatureEvent {
            /// The name of the feature for which this event is associated.
            public static let featureName = "RatingBox"

            /// The name of this event.
            public static let name = "Rating"

            /// The rating value from the user.
            var stars: Int

            func serialized() throws -> JSONObject {
                let json = try encodeObject(self)
                return json
            }
        }
    }
}

// MARK: - RatingBox View Model

final class RatingBoxViewModel: ObservableObject, FeatureViewModel {

    /// Describes error states for this view model.
    enum ViewModelError: Swift.Error {
        /// Indicates that the `feature` was not successfully requested.
        case missingFeature

        /// Indicates that the `FeatureEventPayload` was not successfully generated.
        /// This normally happens if the feature is `off` or hasn't been successfully 
        /// requested yet.
        case missingFeatureEvent
    }

    enum State: Equatable {
        /// The requested feature is not active and should not be rendered.
        case off

        /// The requested feature is currently being fetched.
        case loading

        /// The requested feature has been loaded, is active, and is ready to be rendered.
        /// - Parameter outputs: The loaded feature outputs.
        case on(outputs: RatingBox.Outputs)
    }

    private var feature: RatingBox?
    @Published private(set) var state: State = .loading

    private let client: CausalClientProtocol
    private let featureArgs: RatingBox.Args
    private let impressionId: ImpressionId

    // MARK: Init

    init(client: CausalClientProtocol = CausalClient.shared, productName: String, productPrice: Double, productDescription: String? = nil, impressionId: ImpressionId = .newId()) {
        self.client = client
        self.featureArgs = RatingBox.Args(
            productName: productName,
            productPrice: productPrice,
            productDescription: productDescription
        )
        self.impressionId = impressionId
    }

    // MARK: Feature request

    @MainActor
    func requestFeature() async {
        let _feature = RatingBox(
            productName: self.featureArgs.productName, 
            productPrice: self.featureArgs.productPrice, 
            productDescription: self.featureArgs.productDescription
        )

        self.state = .loading
        let result = await client.requestFeature(_feature, impressionId: self.impressionId)

        if result == nil {
            self.feature = _feature
            switch _feature.status {
                case let .on(outputs):
                    self.state = .on(outputs: outputs)
                case .off:
                    self.state = .off
                case .unrequested:
                    self.state = .loading
            }            
        } else {
            // In the event of an error requesting the feature show default values.
            // Note: Signaled events from this render will be dropped.
            self.state = .on(outputs: RatingBox.Outputs.defaultValues)
        }
    }

    // MARK: Events

    func signal(event: RatingBox.Event, onError: ((Error) -> Void)? = nil) {
        guard let feature else { 
            onError?(ViewModelError.missingFeature)
            return
        }

        guard let featureEvent = feature.event(event) else {
            onError?(ViewModelError.missingFeatureEvent)
            return            
        }

        Task {
            do {
                try await client.signalAndWait(featureEvent: featureEvent)
            } catch {
                onError?(error)
            }
        }
    }
}

// MARK: - ProductInfo



/// An empty feature
final class ProductInfo: FeatureProtocol {
    struct Outputs: FeatureOutputsProtocol, Codable, Hashable {
        let _impressionId: ImpressionId?

        fileprivate init(_impressionId: ImpressionId? = nil) {
            self._impressionId = _impressionId
        }

        fileprivate func with(impressionId: ImpressionId) -> Outputs {
            Outputs(
                _impressionId: impressionId
            )
        }

        static let defaultValues = Outputs()
    }

    struct Args: Codable, Hashable {
    }

    static let name = "ProductInfo"

    /// Feature arguments
    private(set) var args: Args

    /// The status of the feature
    private(set) var status: FeatureStatus<Outputs> = .unrequested

    // MARK: Init

    init() {
        self.args = Args()
    }

    fileprivate init(args: Args) {
        self.args = args
    }

    // MARK: FeatureProtocol

    var id: FeatureId {
        generateIdFrom(name: "ProductInfo", args: self.args)
    }

    func update(request: FeatureUpdateRequest) throws {
        switch request {
        case .off:
             self.status = .off

        case let .on(outputJson, impressionId):
            let cachedOutputs = try decodeObject(from: outputJson, to: Outputs.self)

            if let impressionId {
                let outputsWithImpressionId = cachedOutputs.with(impressionId: impressionId)
                 self.status = .on(outputs: outputsWithImpressionId)
            } else {
                 self.status = .on(outputs: cachedOutputs)
            }
        }
    }

    func event(_ event: Event) -> FeatureEventPayload? {
        guard case let .on(outputs) = status, let impressionId = outputs._impressionId else {
            // Attempting to generate an event for a feature that is not active or doesn't have an associated impression id.
            return nil
        }

        return (event.eventDetails, impressionId)
    }

    func clone() -> ProductInfo {
        let copy = ProductInfo(args: self.args)
        copy.status = self.status
        return copy
    }
}

extension ProductInfo: Equatable {
    public static func == (left: ProductInfo, right: ProductInfo) -> Bool {
        left.args == right.args && left.status == right.status
    }
}

// MARK: ProductInfo Events

extension ProductInfo {
    /// Details all possible session events
    enum Event: FeatureEventProvider {

        var eventDetails: any FeatureEvent {
            switch self {
            }
        }
    }
}

// MARK: - ProductInfo View Model

final class ProductInfoViewModel: ObservableObject, FeatureViewModel {

    /// Describes error states for this view model.
    enum ViewModelError: Swift.Error {
        /// Indicates that the `feature` was not successfully requested.
        case missingFeature

        /// Indicates that the `FeatureEventPayload` was not successfully generated.
        /// This normally happens if the feature is `off` or hasn't been successfully 
        /// requested yet.
        case missingFeatureEvent
    }

    enum State: Equatable {
        /// The requested feature is not active and should not be rendered.
        case off

        /// The requested feature is currently being fetched.
        case loading

        /// The requested feature has been loaded, is active, and is ready to be rendered.
        /// - Parameter outputs: The loaded feature outputs.
        case on(outputs: ProductInfo.Outputs)
    }

    private var feature: ProductInfo?
    @Published private(set) var state: State = .loading

    private let client: CausalClientProtocol
    private let featureArgs: ProductInfo.Args
    private let impressionId: ImpressionId

    // MARK: Init

    init(client: CausalClientProtocol = CausalClient.shared, impressionId: ImpressionId = .newId()) {
        self.client = client
        self.featureArgs = ProductInfo.Args(
        )
        self.impressionId = impressionId
    }

    // MARK: Feature request

    @MainActor
    func requestFeature() async {
        let _feature = ProductInfo(
        )

        self.state = .loading
        let result = await client.requestFeature(_feature, impressionId: self.impressionId)

        if result == nil {
            self.feature = _feature
            switch _feature.status {
                case let .on(outputs):
                    self.state = .on(outputs: outputs)
                case .off:
                    self.state = .off
                case .unrequested:
                    self.state = .loading
            }            
        } else {
            // In the event of an error requesting the feature show default values.
            // Note: Signaled events from this render will be dropped.
            self.state = .on(outputs: ProductInfo.Outputs.defaultValues)
        }
    }

    // MARK: Events

    func signal(event: ProductInfo.Event, onError: ((Error) -> Void)? = nil) {
        guard let feature else { 
            onError?(ViewModelError.missingFeature)
            return
        }

        guard let featureEvent = feature.event(event) else {
            onError?(ViewModelError.missingFeatureEvent)
            return            
        }

        Task {
            do {
                try await client.signalAndWait(featureEvent: featureEvent)
            } catch {
                onError?(error)
            }
        }
    }
}

// MARK: - ProductDisplay



/// A feature with a nested object
final class ProductDisplay: FeatureProtocol {
    struct Outputs: FeatureOutputsProtocol, Codable, Hashable {
        let _impressionId: ImpressionId?

        fileprivate init(_impressionId: ImpressionId? = nil) {
            self._impressionId = _impressionId
        }

        fileprivate func with(impressionId: ImpressionId) -> Outputs {
            Outputs(
                _impressionId: impressionId
            )
        }

        static let defaultValues = Outputs()
    }

    struct Args: Codable, Hashable {
        /// The name.
        let productName: String

        /// TODO: This currently does not work with json handling
        let price: Price

    }

    static let name = "ProductDisplay"

    /// Feature arguments
    private(set) var args: Args

    /// The status of the feature
    private(set) var status: FeatureStatus<Outputs> = .unrequested

    // MARK: Init

    init(productName: String, price: Price) {
        self.args = Args(productName: productName, price: price)
    }

    fileprivate init(args: Args) {
        self.args = args
    }

    // MARK: FeatureProtocol

    var id: FeatureId {
        generateIdFrom(name: "ProductDisplay", args: self.args)
    }

    func update(request: FeatureUpdateRequest) throws {
        switch request {
        case .off:
             self.status = .off

        case let .on(outputJson, impressionId):
            let cachedOutputs = try decodeObject(from: outputJson, to: Outputs.self)

            if let impressionId {
                let outputsWithImpressionId = cachedOutputs.with(impressionId: impressionId)
                 self.status = .on(outputs: outputsWithImpressionId)
            } else {
                 self.status = .on(outputs: cachedOutputs)
            }
        }
    }

    func event(_ event: Event) -> FeatureEventPayload? {
        guard case let .on(outputs) = status, let impressionId = outputs._impressionId else {
            // Attempting to generate an event for a feature that is not active or doesn't have an associated impression id.
            return nil
        }

        return (event.eventDetails, impressionId)
    }

    func clone() -> ProductDisplay {
        let copy = ProductDisplay(args: self.args)
        copy.status = self.status
        return copy
    }
}

extension ProductDisplay: Equatable {
    public static func == (left: ProductDisplay, right: ProductDisplay) -> Bool {
        left.args == right.args && left.status == right.status
    }
}

// MARK: ProductDisplay Events

extension ProductDisplay {
    /// Details all possible session events
    enum Event: FeatureEventProvider {

        var eventDetails: any FeatureEvent {
            switch self {
            }
        }
    }
}

// MARK: - ProductDisplay View Model

final class ProductDisplayViewModel: ObservableObject, FeatureViewModel {

    /// Describes error states for this view model.
    enum ViewModelError: Swift.Error {
        /// Indicates that the `feature` was not successfully requested.
        case missingFeature

        /// Indicates that the `FeatureEventPayload` was not successfully generated.
        /// This normally happens if the feature is `off` or hasn't been successfully 
        /// requested yet.
        case missingFeatureEvent
    }

    enum State: Equatable {
        /// The requested feature is not active and should not be rendered.
        case off

        /// The requested feature is currently being fetched.
        case loading

        /// The requested feature has been loaded, is active, and is ready to be rendered.
        /// - Parameter outputs: The loaded feature outputs.
        case on(outputs: ProductDisplay.Outputs)
    }

    private var feature: ProductDisplay?
    @Published private(set) var state: State = .loading

    private let client: CausalClientProtocol
    private let featureArgs: ProductDisplay.Args
    private let impressionId: ImpressionId

    // MARK: Init

    init(client: CausalClientProtocol = CausalClient.shared, productName: String, price: Price, impressionId: ImpressionId = .newId()) {
        self.client = client
        self.featureArgs = ProductDisplay.Args(
            productName: productName,
            price: price
        )
        self.impressionId = impressionId
    }

    // MARK: Feature request

    @MainActor
    func requestFeature() async {
        let _feature = ProductDisplay(
            productName: self.featureArgs.productName, 
            price: self.featureArgs.price
        )

        self.state = .loading
        let result = await client.requestFeature(_feature, impressionId: self.impressionId)

        if result == nil {
            self.feature = _feature
            switch _feature.status {
                case let .on(outputs):
                    self.state = .on(outputs: outputs)
                case .off:
                    self.state = .off
                case .unrequested:
                    self.state = .loading
            }            
        } else {
            // In the event of an error requesting the feature show default values.
            // Note: Signaled events from this render will be dropped.
            self.state = .on(outputs: ProductDisplay.Outputs.defaultValues)
        }
    }

    // MARK: Events

    func signal(event: ProductDisplay.Event, onError: ((Error) -> Void)? = nil) {
        guard let feature else { 
            onError?(ViewModelError.missingFeature)
            return
        }

        guard let featureEvent = feature.event(event) else {
            onError?(ViewModelError.missingFeatureEvent)
            return            
        }

        Task {
            do {
                try await client.signalAndWait(featureEvent: featureEvent)
            } catch {
                onError?(error)
            }
        }
    }
}

// MARK: - EmptyFeature



final class EmptyFeature: FeatureProtocol {
    struct Outputs: FeatureOutputsProtocol, Codable, Hashable {
        let _impressionId: ImpressionId?

        fileprivate init(_impressionId: ImpressionId? = nil) {
            self._impressionId = _impressionId
        }

        fileprivate func with(impressionId: ImpressionId) -> Outputs {
            Outputs(
                _impressionId: impressionId
            )
        }

        static let defaultValues = Outputs()
    }

    struct Args: Codable, Hashable {
    }

    static let name = "EmptyFeature"

    /// Feature arguments
    private(set) var args: Args

    /// The status of the feature
    private(set) var status: FeatureStatus<Outputs> = .unrequested

    // MARK: Init

    init() {
        self.args = Args()
    }

    fileprivate init(args: Args) {
        self.args = args
    }

    // MARK: FeatureProtocol

    var id: FeatureId {
        generateIdFrom(name: "EmptyFeature", args: self.args)
    }

    func update(request: FeatureUpdateRequest) throws {
        switch request {
        case .off:
             self.status = .off

        case let .on(outputJson, impressionId):
            let cachedOutputs = try decodeObject(from: outputJson, to: Outputs.self)

            if let impressionId {
                let outputsWithImpressionId = cachedOutputs.with(impressionId: impressionId)
                 self.status = .on(outputs: outputsWithImpressionId)
            } else {
                 self.status = .on(outputs: cachedOutputs)
            }
        }
    }

    func event(_ event: Event) -> FeatureEventPayload? {
        guard case let .on(outputs) = status, let impressionId = outputs._impressionId else {
            // Attempting to generate an event for a feature that is not active or doesn't have an associated impression id.
            return nil
        }

        return (event.eventDetails, impressionId)
    }

    func clone() -> EmptyFeature {
        let copy = EmptyFeature(args: self.args)
        copy.status = self.status
        return copy
    }
}

extension EmptyFeature: Equatable {
    public static func == (left: EmptyFeature, right: EmptyFeature) -> Bool {
        left.args == right.args && left.status == right.status
    }
}

// MARK: EmptyFeature Events

extension EmptyFeature {
    /// Details all possible session events
    enum Event: FeatureEventProvider {

        var eventDetails: any FeatureEvent {
            switch self {
            }
        }
    }
}

// MARK: - EmptyFeature View Model

final class EmptyFeatureViewModel: ObservableObject, FeatureViewModel {

    /// Describes error states for this view model.
    enum ViewModelError: Swift.Error {
        /// Indicates that the `feature` was not successfully requested.
        case missingFeature

        /// Indicates that the `FeatureEventPayload` was not successfully generated.
        /// This normally happens if the feature is `off` or hasn't been successfully 
        /// requested yet.
        case missingFeatureEvent
    }

    enum State: Equatable {
        /// The requested feature is not active and should not be rendered.
        case off

        /// The requested feature is currently being fetched.
        case loading

        /// The requested feature has been loaded, is active, and is ready to be rendered.
        /// - Parameter outputs: The loaded feature outputs.
        case on(outputs: EmptyFeature.Outputs)
    }

    private var feature: EmptyFeature?
    @Published private(set) var state: State = .loading

    private let client: CausalClientProtocol
    private let featureArgs: EmptyFeature.Args
    private let impressionId: ImpressionId

    // MARK: Init

    init(client: CausalClientProtocol = CausalClient.shared, impressionId: ImpressionId = .newId()) {
        self.client = client
        self.featureArgs = EmptyFeature.Args(
        )
        self.impressionId = impressionId
    }

    // MARK: Feature request

    @MainActor
    func requestFeature() async {
        let _feature = EmptyFeature(
        )

        self.state = .loading
        let result = await client.requestFeature(_feature, impressionId: self.impressionId)

        if result == nil {
            self.feature = _feature
            switch _feature.status {
                case let .on(outputs):
                    self.state = .on(outputs: outputs)
                case .off:
                    self.state = .off
                case .unrequested:
                    self.state = .loading
            }            
        } else {
            // In the event of an error requesting the feature show default values.
            // Note: Signaled events from this render will be dropped.
            self.state = .on(outputs: EmptyFeature.Outputs.defaultValues)
        }
    }

    // MARK: Events

    func signal(event: EmptyFeature.Event, onError: ((Error) -> Void)? = nil) {
        guard let feature else { 
            onError?(ViewModelError.missingFeature)
            return
        }

        guard let featureEvent = feature.event(event) else {
            onError?(ViewModelError.missingFeatureEvent)
            return            
        }

        Task {
            do {
                try await client.signalAndWait(featureEvent: featureEvent)
            } catch {
                onError?(error)
            }
        }
    }
}

// MARK: - StrangeFeature



final class StrangeFeature: FeatureProtocol {
    struct Outputs: FeatureOutputsProtocol, Codable, Hashable {
        let _impressionId: ImpressionId?

        fileprivate init(_impressionId: ImpressionId? = nil) {
            self._impressionId = _impressionId
        }

        fileprivate func with(impressionId: ImpressionId) -> Outputs {
            Outputs(
                _impressionId: impressionId
            )
        }

        static let defaultValues = Outputs()
    }

    struct Args: Codable, Hashable {
    }

    static let name = "StrangeFeature"

    /// Feature arguments
    private(set) var args: Args

    /// The status of the feature
    private(set) var status: FeatureStatus<Outputs> = .unrequested

    // MARK: Init

    init() {
        self.args = Args()
    }

    fileprivate init(args: Args) {
        self.args = args
    }

    // MARK: FeatureProtocol

    var id: FeatureId {
        generateIdFrom(name: "StrangeFeature", args: self.args)
    }

    func update(request: FeatureUpdateRequest) throws {
        switch request {
        case .off:
             self.status = .off

        case let .on(outputJson, impressionId):
            let cachedOutputs = try decodeObject(from: outputJson, to: Outputs.self)

            if let impressionId {
                let outputsWithImpressionId = cachedOutputs.with(impressionId: impressionId)
                 self.status = .on(outputs: outputsWithImpressionId)
            } else {
                 self.status = .on(outputs: cachedOutputs)
            }
        }
    }

    func event(_ event: Event) -> FeatureEventPayload? {
        guard case let .on(outputs) = status, let impressionId = outputs._impressionId else {
            // Attempting to generate an event for a feature that is not active or doesn't have an associated impression id.
            return nil
        }

        return (event.eventDetails, impressionId)
    }

    func clone() -> StrangeFeature {
        let copy = StrangeFeature(args: self.args)
        copy.status = self.status
        return copy
    }
}

extension StrangeFeature: Equatable {
    public static func == (left: StrangeFeature, right: StrangeFeature) -> Bool {
        left.args == right.args && left.status == right.status
    }
}

// MARK: StrangeFeature Events

extension StrangeFeature {
    /// Details all possible session events
    enum Event: FeatureEventProvider {

        case noParamEvent

        var eventDetails: any FeatureEvent {
            switch self {
                case .noParamEvent:
                    return NoParamEvent()
            }
        }

        struct NoParamEvent: FeatureEvent {
            /// The name of the feature for which this event is associated.
            public static let featureName = "StrangeFeature"

            /// The name of this event.
            public static let name = "NoParamEvent"

            func serialized() throws -> JSONObject {
                let json = try encodeObject(self)
                return json
            }
        }
    }
}

// MARK: - StrangeFeature View Model

final class StrangeFeatureViewModel: ObservableObject, FeatureViewModel {

    /// Describes error states for this view model.
    enum ViewModelError: Swift.Error {
        /// Indicates that the `feature` was not successfully requested.
        case missingFeature

        /// Indicates that the `FeatureEventPayload` was not successfully generated.
        /// This normally happens if the feature is `off` or hasn't been successfully 
        /// requested yet.
        case missingFeatureEvent
    }

    enum State: Equatable {
        /// The requested feature is not active and should not be rendered.
        case off

        /// The requested feature is currently being fetched.
        case loading

        /// The requested feature has been loaded, is active, and is ready to be rendered.
        /// - Parameter outputs: The loaded feature outputs.
        case on(outputs: StrangeFeature.Outputs)
    }

    private var feature: StrangeFeature?
    @Published private(set) var state: State = .loading

    private let client: CausalClientProtocol
    private let featureArgs: StrangeFeature.Args
    private let impressionId: ImpressionId

    // MARK: Init

    init(client: CausalClientProtocol = CausalClient.shared, impressionId: ImpressionId = .newId()) {
        self.client = client
        self.featureArgs = StrangeFeature.Args(
        )
        self.impressionId = impressionId
    }

    // MARK: Feature request

    @MainActor
    func requestFeature() async {
        let _feature = StrangeFeature(
        )

        self.state = .loading
        let result = await client.requestFeature(_feature, impressionId: self.impressionId)

        if result == nil {
            self.feature = _feature
            switch _feature.status {
                case let .on(outputs):
                    self.state = .on(outputs: outputs)
                case .off:
                    self.state = .off
                case .unrequested:
                    self.state = .loading
            }            
        } else {
            // In the event of an error requesting the feature show default values.
            // Note: Signaled events from this render will be dropped.
            self.state = .on(outputs: StrangeFeature.Outputs.defaultValues)
        }
    }

    // MARK: Events

    func signal(event: StrangeFeature.Event, onError: ((Error) -> Void)? = nil) {
        guard let feature else { 
            onError?(ViewModelError.missingFeature)
            return
        }

        guard let featureEvent = feature.event(event) else {
            onError?(ViewModelError.missingFeatureEvent)
            return            
        }

        Task {
            do {
                try await client.signalAndWait(featureEvent: featureEvent)
            } catch {
                onError?(error)
            }
        }
    }
}

// MARK: - Commerce



/// Feature representing a page that contains commerce buttons
/// @deprecated reason
@available(*, deprecated, message: "reason")
final class Commerce: FeatureProtocol {
    struct Outputs: FeatureOutputsProtocol, Codable, Hashable {
        /// Material UI palette color for commerce buttons
        let commerceButtonColor: Color

        /// 
        /// @deprecated reason
        @available(*, deprecated, message: "reason")
        let ctaText: String

        let nullable: String?

        let _impressionId: ImpressionId?

        fileprivate init(commerceButtonColor: Color = .PRIMARY, ctaText: String = "View Deal", nullable: String? = "non null default value", _impressionId: ImpressionId? = nil) {
            self.commerceButtonColor = commerceButtonColor
            self.ctaText = ctaText
            self.nullable = nullable
            self._impressionId = _impressionId
        }

        fileprivate func with(impressionId: ImpressionId) -> Outputs {
            Outputs(
                commerceButtonColor: self.commerceButtonColor,
                ctaText: self.ctaText,
                nullable: self.nullable,
                _impressionId: impressionId
            )
        }

        static let defaultValues = Outputs()
    }

    struct Args: Codable, Hashable {
    }

    static let name = "Commerce"

    /// Feature arguments
    private(set) var args: Args

    /// The status of the feature
    private(set) var status: FeatureStatus<Outputs> = .unrequested

    // MARK: Init

    init() {
        self.args = Args()
    }

    fileprivate init(args: Args) {
        self.args = args
    }

    // MARK: FeatureProtocol

    var id: FeatureId {
        generateIdFrom(name: "Commerce", args: self.args)
    }

    func update(request: FeatureUpdateRequest) throws {
        switch request {
        case .off:
             self.status = .off

        case let .on(outputJson, impressionId):
            let cachedOutputs = try decodeObject(from: outputJson, to: Outputs.self)

            if let impressionId {
                let outputsWithImpressionId = cachedOutputs.with(impressionId: impressionId)
                 self.status = .on(outputs: outputsWithImpressionId)
            } else {
                 self.status = .on(outputs: cachedOutputs)
            }
        }
    }

    func event(_ event: Event) -> FeatureEventPayload? {
        guard case let .on(outputs) = status, let impressionId = outputs._impressionId else {
            // Attempting to generate an event for a feature that is not active or doesn't have an associated impression id.
            return nil
        }

        return (event.eventDetails, impressionId)
    }

    func clone() -> Commerce {
        let copy = Commerce(args: self.args)
        copy.status = self.status
        return copy
    }
}

extension Commerce: Equatable {
    public static func == (left: Commerce, right: Commerce) -> Bool {
        left.args == right.args && left.status == right.status
    }
}

// MARK: Commerce Events

extension Commerce {
    /// Details all possible session events
    enum Event: FeatureEventProvider {

        /// This represents a click on a commence button, leading to a partner.
        /// @deprecated I don&#39;t know why
        /// - Parameter productId: 
        /// - Parameter price: 
        @available(*, deprecated, message: "I don&#39;t know why")
        case commerceClick(productId: String, price: Price? = nil)

        var eventDetails: any FeatureEvent {
            switch self {
                case .commerceClick(let productId, let price):
                    return CommerceClick(productId: productId, price: price)
            }
        }

        /// This represents a click on a commence button, leading to a partner.
        /// @deprecated I don&#39;t know why
        @available(*, deprecated, message: "I don&#39;t know why")
        struct CommerceClick: FeatureEvent {
            /// The name of the feature for which this event is associated.
            public static let featureName = "Commerce"

            /// The name of this event.
            public static let name = "CommerceClick"

            var productId: String

            var price: Price?

            func serialized() throws -> JSONObject {
                let json = try encodeObject(self)
                return json
            }
        }
    }
}

// MARK: - Commerce View Model

final class CommerceViewModel: ObservableObject, FeatureViewModel {

    /// Describes error states for this view model.
    enum ViewModelError: Swift.Error {
        /// Indicates that the `feature` was not successfully requested.
        case missingFeature

        /// Indicates that the `FeatureEventPayload` was not successfully generated.
        /// This normally happens if the feature is `off` or hasn't been successfully 
        /// requested yet.
        case missingFeatureEvent
    }

    enum State: Equatable {
        /// The requested feature is not active and should not be rendered.
        case off

        /// The requested feature is currently being fetched.
        case loading

        /// The requested feature has been loaded, is active, and is ready to be rendered.
        /// - Parameter outputs: The loaded feature outputs.
        case on(outputs: Commerce.Outputs)
    }

    private var feature: Commerce?
    @Published private(set) var state: State = .loading

    private let client: CausalClientProtocol
    private let featureArgs: Commerce.Args
    private let impressionId: ImpressionId

    // MARK: Init

    init(client: CausalClientProtocol = CausalClient.shared, impressionId: ImpressionId = .newId()) {
        self.client = client
        self.featureArgs = Commerce.Args(
        )
        self.impressionId = impressionId
    }

    // MARK: Feature request

    @MainActor
    func requestFeature() async {
        let _feature = Commerce(
        )

        self.state = .loading
        let result = await client.requestFeature(_feature, impressionId: self.impressionId)

        if result == nil {
            self.feature = _feature
            switch _feature.status {
                case let .on(outputs):
                    self.state = .on(outputs: outputs)
                case .off:
                    self.state = .off
                case .unrequested:
                    self.state = .loading
            }            
        } else {
            // In the event of an error requesting the feature show default values.
            // Note: Signaled events from this render will be dropped.
            self.state = .on(outputs: Commerce.Outputs.defaultValues)
        }
    }

    // MARK: Events

    func signal(event: Commerce.Event, onError: ((Error) -> Void)? = nil) {
        guard let feature else { 
            onError?(ViewModelError.missingFeature)
            return
        }

        guard let featureEvent = feature.event(event) else {
            onError?(ViewModelError.missingFeatureEvent)
            return            
        }

        Task {
            do {
                try await client.signalAndWait(featureEvent: featureEvent)
            } catch {
                onError?(error)
            }
        }
    }
}

// MARK: - Feature_with_underscores



final class Feature_with_underscores: FeatureProtocol {
    struct Outputs: FeatureOutputsProtocol, Codable, Hashable {
        let a_value: String

        let _impressionId: ImpressionId?

        fileprivate init(a_value: String = "value", _impressionId: ImpressionId? = nil) {
            self.a_value = a_value
            self._impressionId = _impressionId
        }

        fileprivate func with(impressionId: ImpressionId) -> Outputs {
            Outputs(
                a_value: self.a_value,
                _impressionId: impressionId
            )
        }

        static let defaultValues = Outputs()
    }

    struct Args: Codable, Hashable {
    }

    static let name = "Feature_with_underscores"

    /// Feature arguments
    private(set) var args: Args

    /// The status of the feature
    private(set) var status: FeatureStatus<Outputs> = .unrequested

    // MARK: Init

    init() {
        self.args = Args()
    }

    fileprivate init(args: Args) {
        self.args = args
    }

    // MARK: FeatureProtocol

    var id: FeatureId {
        generateIdFrom(name: "Feature_with_underscores", args: self.args)
    }

    func update(request: FeatureUpdateRequest) throws {
        switch request {
        case .off:
             self.status = .off

        case let .on(outputJson, impressionId):
            let cachedOutputs = try decodeObject(from: outputJson, to: Outputs.self)

            if let impressionId {
                let outputsWithImpressionId = cachedOutputs.with(impressionId: impressionId)
                 self.status = .on(outputs: outputsWithImpressionId)
            } else {
                 self.status = .on(outputs: cachedOutputs)
            }
        }
    }

    func event(_ event: Event) -> FeatureEventPayload? {
        guard case let .on(outputs) = status, let impressionId = outputs._impressionId else {
            // Attempting to generate an event for a feature that is not active or doesn't have an associated impression id.
            return nil
        }

        return (event.eventDetails, impressionId)
    }

    func clone() -> Feature_with_underscores {
        let copy = Feature_with_underscores(args: self.args)
        copy.status = self.status
        return copy
    }
}

extension Feature_with_underscores: Equatable {
    public static func == (left: Feature_with_underscores, right: Feature_with_underscores) -> Bool {
        left.args == right.args && left.status == right.status
    }
}

// MARK: Feature_with_underscores Events

extension Feature_with_underscores {
    /// Details all possible session events
    enum Event: FeatureEventProvider {

        var eventDetails: any FeatureEvent {
            switch self {
            }
        }
    }
}

// MARK: - Feature_with_underscores View Model

final class Feature_with_underscoresViewModel: ObservableObject, FeatureViewModel {

    /// Describes error states for this view model.
    enum ViewModelError: Swift.Error {
        /// Indicates that the `feature` was not successfully requested.
        case missingFeature

        /// Indicates that the `FeatureEventPayload` was not successfully generated.
        /// This normally happens if the feature is `off` or hasn't been successfully 
        /// requested yet.
        case missingFeatureEvent
    }

    enum State: Equatable {
        /// The requested feature is not active and should not be rendered.
        case off

        /// The requested feature is currently being fetched.
        case loading

        /// The requested feature has been loaded, is active, and is ready to be rendered.
        /// - Parameter outputs: The loaded feature outputs.
        case on(outputs: Feature_with_underscores.Outputs)
    }

    private var feature: Feature_with_underscores?
    @Published private(set) var state: State = .loading

    private let client: CausalClientProtocol
    private let featureArgs: Feature_with_underscores.Args
    private let impressionId: ImpressionId

    // MARK: Init

    init(client: CausalClientProtocol = CausalClient.shared, impressionId: ImpressionId = .newId()) {
        self.client = client
        self.featureArgs = Feature_with_underscores.Args(
        )
        self.impressionId = impressionId
    }

    // MARK: Feature request

    @MainActor
    func requestFeature() async {
        let _feature = Feature_with_underscores(
        )

        self.state = .loading
        let result = await client.requestFeature(_feature, impressionId: self.impressionId)

        if result == nil {
            self.feature = _feature
            switch _feature.status {
                case let .on(outputs):
                    self.state = .on(outputs: outputs)
                case .off:
                    self.state = .off
                case .unrequested:
                    self.state = .loading
            }            
        } else {
            // In the event of an error requesting the feature show default values.
            // Note: Signaled events from this render will be dropped.
            self.state = .on(outputs: Feature_with_underscores.Outputs.defaultValues)
        }
    }

    // MARK: Events

    func signal(event: Feature_with_underscores.Event, onError: ((Error) -> Void)? = nil) {
        guard let feature else { 
            onError?(ViewModelError.missingFeature)
            return
        }

        guard let featureEvent = feature.event(event) else {
            onError?(ViewModelError.missingFeatureEvent)
            return            
        }

        Task {
            do {
                try await client.signalAndWait(featureEvent: featureEvent)
            } catch {
                onError?(error)
            }
        }
    }
}

// MARK: - featureThatStartsWithLowercase



final class featureThatStartsWithLowercase: FeatureProtocol {
    struct Outputs: FeatureOutputsProtocol, Codable, Hashable {
        let a_value: String

        let _impressionId: ImpressionId?

        fileprivate init(a_value: String = "value", _impressionId: ImpressionId? = nil) {
            self.a_value = a_value
            self._impressionId = _impressionId
        }

        fileprivate func with(impressionId: ImpressionId) -> Outputs {
            Outputs(
                a_value: self.a_value,
                _impressionId: impressionId
            )
        }

        static let defaultValues = Outputs()
    }

    struct Args: Codable, Hashable {
    }

    static let name = "featureThatStartsWithLowercase"

    /// Feature arguments
    private(set) var args: Args

    /// The status of the feature
    private(set) var status: FeatureStatus<Outputs> = .unrequested

    // MARK: Init

    init() {
        self.args = Args()
    }

    fileprivate init(args: Args) {
        self.args = args
    }

    // MARK: FeatureProtocol

    var id: FeatureId {
        generateIdFrom(name: "featureThatStartsWithLowercase", args: self.args)
    }

    func update(request: FeatureUpdateRequest) throws {
        switch request {
        case .off:
             self.status = .off

        case let .on(outputJson, impressionId):
            let cachedOutputs = try decodeObject(from: outputJson, to: Outputs.self)

            if let impressionId {
                let outputsWithImpressionId = cachedOutputs.with(impressionId: impressionId)
                 self.status = .on(outputs: outputsWithImpressionId)
            } else {
                 self.status = .on(outputs: cachedOutputs)
            }
        }
    }

    func event(_ event: Event) -> FeatureEventPayload? {
        guard case let .on(outputs) = status, let impressionId = outputs._impressionId else {
            // Attempting to generate an event for a feature that is not active or doesn't have an associated impression id.
            return nil
        }

        return (event.eventDetails, impressionId)
    }

    func clone() -> featureThatStartsWithLowercase {
        let copy = featureThatStartsWithLowercase(args: self.args)
        copy.status = self.status
        return copy
    }
}

extension featureThatStartsWithLowercase: Equatable {
    public static func == (left: featureThatStartsWithLowercase, right: featureThatStartsWithLowercase) -> Bool {
        left.args == right.args && left.status == right.status
    }
}

// MARK: featureThatStartsWithLowercase Events

extension featureThatStartsWithLowercase {
    /// Details all possible session events
    enum Event: FeatureEventProvider {

        var eventDetails: any FeatureEvent {
            switch self {
            }
        }
    }
}

// MARK: - featureThatStartsWithLowercase View Model

final class featureThatStartsWithLowercaseViewModel: ObservableObject, FeatureViewModel {

    /// Describes error states for this view model.
    enum ViewModelError: Swift.Error {
        /// Indicates that the `feature` was not successfully requested.
        case missingFeature

        /// Indicates that the `FeatureEventPayload` was not successfully generated.
        /// This normally happens if the feature is `off` or hasn't been successfully 
        /// requested yet.
        case missingFeatureEvent
    }

    enum State: Equatable {
        /// The requested feature is not active and should not be rendered.
        case off

        /// The requested feature is currently being fetched.
        case loading

        /// The requested feature has been loaded, is active, and is ready to be rendered.
        /// - Parameter outputs: The loaded feature outputs.
        case on(outputs: featureThatStartsWithLowercase.Outputs)
    }

    private var feature: featureThatStartsWithLowercase?
    @Published private(set) var state: State = .loading

    private let client: CausalClientProtocol
    private let featureArgs: featureThatStartsWithLowercase.Args
    private let impressionId: ImpressionId

    // MARK: Init

    init(client: CausalClientProtocol = CausalClient.shared, impressionId: ImpressionId = .newId()) {
        self.client = client
        self.featureArgs = featureThatStartsWithLowercase.Args(
        )
        self.impressionId = impressionId
    }

    // MARK: Feature request

    @MainActor
    func requestFeature() async {
        let _feature = featureThatStartsWithLowercase(
        )

        self.state = .loading
        let result = await client.requestFeature(_feature, impressionId: self.impressionId)

        if result == nil {
            self.feature = _feature
            switch _feature.status {
                case let .on(outputs):
                    self.state = .on(outputs: outputs)
                case .off:
                    self.state = .off
                case .unrequested:
                    self.state = .loading
            }            
        } else {
            // In the event of an error requesting the feature show default values.
            // Note: Signaled events from this render will be dropped.
            self.state = .on(outputs: featureThatStartsWithLowercase.Outputs.defaultValues)
        }
    }

    // MARK: Events

    func signal(event: featureThatStartsWithLowercase.Event, onError: ((Error) -> Void)? = nil) {
        guard let feature else { 
            onError?(ViewModelError.missingFeature)
            return
        }

        guard let featureEvent = feature.event(event) else {
            onError?(ViewModelError.missingFeatureEvent)
            return            
        }

        Task {
            do {
                try await client.signalAndWait(featureEvent: featureEvent)
            } catch {
                onError?(error)
            }
        }
    }
}

// MARK: - CrossSellRoot



// MARK: - CrossSell



final class CrossSell: FeatureProtocol {
    struct Outputs: FeatureOutputsProtocol, Codable, Hashable {
        let baseOnly: String

        let customerData: CustomerData

        let crosssellProductids: [String]

        let nullable: String?

        let _impressionId: ImpressionId?

        fileprivate init(baseOnly: String = "base", customerData: CustomerData = CustomerData(zip: "02445", productViews: 1, lastViews: ["123", "456"]), crosssellProductids: [String] = ["60745"], nullable: String? = "default response", _impressionId: ImpressionId? = nil) {
            self.baseOnly = baseOnly
            self.customerData = customerData
            self.crosssellProductids = crosssellProductids
            self.nullable = nullable
            self._impressionId = _impressionId
        }

        fileprivate func with(impressionId: ImpressionId) -> Outputs {
            Outputs(
                baseOnly: self.baseOnly,
                customerData: self.customerData,
                crosssellProductids: self.crosssellProductids,
                nullable: self.nullable,
                _impressionId: impressionId
            )
        }

        static let defaultValues = Outputs()
    }

    struct Args: Codable, Hashable {
        /// The locationid for the source product in an item based collaborative filter
        let productId: String

        let price: Price?

        let withDefault: String?

    }

    static let name = "CrossSell"

    /// Feature arguments
    private(set) var args: Args

    /// The status of the feature
    private(set) var status: FeatureStatus<Outputs> = .unrequested

    // MARK: Init

    init(productId: String, price: Price? = nil, withDefault: String? = "another default") {
        self.args = Args(productId: productId, price: price, withDefault: withDefault)
    }

    fileprivate init(args: Args) {
        self.args = args
    }

    // MARK: FeatureProtocol

    var id: FeatureId {
        generateIdFrom(name: "CrossSell", args: self.args)
    }

    func update(request: FeatureUpdateRequest) throws {
        switch request {
        case .off:
             self.status = .off

        case let .on(outputJson, impressionId):
            let cachedOutputs = try decodeObject(from: outputJson, to: Outputs.self)

            if let impressionId {
                let outputsWithImpressionId = cachedOutputs.with(impressionId: impressionId)
                 self.status = .on(outputs: outputsWithImpressionId)
            } else {
                 self.status = .on(outputs: cachedOutputs)
            }
        }
    }

    func event(_ event: Event) -> FeatureEventPayload? {
        guard case let .on(outputs) = status, let impressionId = outputs._impressionId else {
            // Attempting to generate an event for a feature that is not active or doesn't have an associated impression id.
            return nil
        }

        return (event.eventDetails, impressionId)
    }

    func clone() -> CrossSell {
        let copy = CrossSell(args: self.args)
        copy.status = self.status
        return copy
    }
}

extension CrossSell: Equatable {
    public static func == (left: CrossSell, right: CrossSell) -> Bool {
        left.args == right.args && left.status == right.status
    }
}

// MARK: CrossSell Events

extension CrossSell {
    /// Details all possible session events
    enum Event: FeatureEventProvider {

        case crossSellClick(productId: String)

        case eventA(anInt: Int? = 7777)

        var eventDetails: any FeatureEvent {
            switch self {
                case .crossSellClick(let productId):
                    return CrossSellClick(productId: productId)
                case .eventA(let anInt):
                    return EventA(anInt: anInt)
            }
        }

        struct CrossSellClick: FeatureEvent {
            /// The name of the feature for which this event is associated.
            public static let featureName = "CrossSell"

            /// The name of this event.
            public static let name = "CrossSellClick"

            var productId: String

            func serialized() throws -> JSONObject {
                let json = try encodeObject(self)
                return json
            }
        }

        struct EventA: FeatureEvent {
            /// The name of the feature for which this event is associated.
            public static let featureName = "CrossSell"

            /// The name of this event.
            public static let name = "EventA"

            var anInt: Int?

            func serialized() throws -> JSONObject {
                let json = try encodeObject(self)
                return json
            }
        }
    }
}

// MARK: - CrossSell View Model

final class CrossSellViewModel: ObservableObject, FeatureViewModel {

    /// Describes error states for this view model.
    enum ViewModelError: Swift.Error {
        /// Indicates that the `feature` was not successfully requested.
        case missingFeature

        /// Indicates that the `FeatureEventPayload` was not successfully generated.
        /// This normally happens if the feature is `off` or hasn't been successfully 
        /// requested yet.
        case missingFeatureEvent
    }

    enum State: Equatable {
        /// The requested feature is not active and should not be rendered.
        case off

        /// The requested feature is currently being fetched.
        case loading

        /// The requested feature has been loaded, is active, and is ready to be rendered.
        /// - Parameter outputs: The loaded feature outputs.
        case on(outputs: CrossSell.Outputs)
    }

    private var feature: CrossSell?
    @Published private(set) var state: State = .loading

    private let client: CausalClientProtocol
    private let featureArgs: CrossSell.Args
    private let impressionId: ImpressionId

    // MARK: Init

    init(client: CausalClientProtocol = CausalClient.shared, productId: String, price: Price? = nil, withDefault: String? = "another default", impressionId: ImpressionId = .newId()) {
        self.client = client
        self.featureArgs = CrossSell.Args(
            productId: productId,
            price: price,
            withDefault: withDefault
        )
        self.impressionId = impressionId
    }

    // MARK: Feature request

    @MainActor
    func requestFeature() async {
        let _feature = CrossSell(
            productId: self.featureArgs.productId, 
            price: self.featureArgs.price, 
            withDefault: self.featureArgs.withDefault
        )

        self.state = .loading
        let result = await client.requestFeature(_feature, impressionId: self.impressionId)

        if result == nil {
            self.feature = _feature
            switch _feature.status {
                case let .on(outputs):
                    self.state = .on(outputs: outputs)
                case .off:
                    self.state = .off
                case .unrequested:
                    self.state = .loading
            }            
        } else {
            // In the event of an error requesting the feature show default values.
            // Note: Signaled events from this render will be dropped.
            self.state = .on(outputs: CrossSell.Outputs.defaultValues)
        }
    }

    // MARK: Events

    func signal(event: CrossSell.Event, onError: ((Error) -> Void)? = nil) {
        guard let feature else { 
            onError?(ViewModelError.missingFeature)
            return
        }

        guard let featureEvent = feature.event(event) else {
            onError?(ViewModelError.missingFeatureEvent)
            return            
        }

        Task {
            do {
                try await client.signalAndWait(featureEvent: featureEvent)
            } catch {
                onError?(error)
            }
        }
    }
}

// MARK: - CrossSell2



final class CrossSell2: FeatureProtocol {
    struct Outputs: FeatureOutputsProtocol, Codable, Hashable {
        let baseOnly: String

        let customerData: CustomerData

        let crosssellProductids: [String]

        let two: String

        let _impressionId: ImpressionId?

        fileprivate init(baseOnly: String = "base", customerData: CustomerData = CustomerData(zip: "02445", productViews: 1, lastViews: ["123", "456"]), crosssellProductids: [String] = ["60745"], two: String = "two", _impressionId: ImpressionId? = nil) {
            self.baseOnly = baseOnly
            self.customerData = customerData
            self.crosssellProductids = crosssellProductids
            self.two = two
            self._impressionId = _impressionId
        }

        fileprivate func with(impressionId: ImpressionId) -> Outputs {
            Outputs(
                baseOnly: self.baseOnly,
                customerData: self.customerData,
                crosssellProductids: self.crosssellProductids,
                two: self.two,
                _impressionId: impressionId
            )
        }

        static let defaultValues = Outputs()
    }

    struct Args: Codable, Hashable {
        /// The locationid for the source product in an item based collaborative filter
        let productId: String

        let price: Price?

    }

    static let name = "CrossSell2"

    /// Feature arguments
    private(set) var args: Args

    /// The status of the feature
    private(set) var status: FeatureStatus<Outputs> = .unrequested

    // MARK: Init

    init(productId: String, price: Price? = nil) {
        self.args = Args(productId: productId, price: price)
    }

    fileprivate init(args: Args) {
        self.args = args
    }

    // MARK: FeatureProtocol

    var id: FeatureId {
        generateIdFrom(name: "CrossSell2", args: self.args)
    }

    func update(request: FeatureUpdateRequest) throws {
        switch request {
        case .off:
             self.status = .off

        case let .on(outputJson, impressionId):
            let cachedOutputs = try decodeObject(from: outputJson, to: Outputs.self)

            if let impressionId {
                let outputsWithImpressionId = cachedOutputs.with(impressionId: impressionId)
                 self.status = .on(outputs: outputsWithImpressionId)
            } else {
                 self.status = .on(outputs: cachedOutputs)
            }
        }
    }

    func event(_ event: Event) -> FeatureEventPayload? {
        guard case let .on(outputs) = status, let impressionId = outputs._impressionId else {
            // Attempting to generate an event for a feature that is not active or doesn't have an associated impression id.
            return nil
        }

        return (event.eventDetails, impressionId)
    }

    func clone() -> CrossSell2 {
        let copy = CrossSell2(args: self.args)
        copy.status = self.status
        return copy
    }
}

extension CrossSell2: Equatable {
    public static func == (left: CrossSell2, right: CrossSell2) -> Bool {
        left.args == right.args && left.status == right.status
    }
}

// MARK: CrossSell2 Events

extension CrossSell2 {
    /// Details all possible session events
    enum Event: FeatureEventProvider {

        case crossSellClick(productId: String)

        var eventDetails: any FeatureEvent {
            switch self {
                case .crossSellClick(let productId):
                    return CrossSellClick(productId: productId)
            }
        }

        struct CrossSellClick: FeatureEvent {
            /// The name of the feature for which this event is associated.
            public static let featureName = "CrossSell2"

            /// The name of this event.
            public static let name = "CrossSellClick"

            var productId: String

            func serialized() throws -> JSONObject {
                let json = try encodeObject(self)
                return json
            }
        }
    }
}

// MARK: - CrossSell2 View Model

final class CrossSell2ViewModel: ObservableObject, FeatureViewModel {

    /// Describes error states for this view model.
    enum ViewModelError: Swift.Error {
        /// Indicates that the `feature` was not successfully requested.
        case missingFeature

        /// Indicates that the `FeatureEventPayload` was not successfully generated.
        /// This normally happens if the feature is `off` or hasn't been successfully 
        /// requested yet.
        case missingFeatureEvent
    }

    enum State: Equatable {
        /// The requested feature is not active and should not be rendered.
        case off

        /// The requested feature is currently being fetched.
        case loading

        /// The requested feature has been loaded, is active, and is ready to be rendered.
        /// - Parameter outputs: The loaded feature outputs.
        case on(outputs: CrossSell2.Outputs)
    }

    private var feature: CrossSell2?
    @Published private(set) var state: State = .loading

    private let client: CausalClientProtocol
    private let featureArgs: CrossSell2.Args
    private let impressionId: ImpressionId

    // MARK: Init

    init(client: CausalClientProtocol = CausalClient.shared, productId: String, price: Price? = nil, impressionId: ImpressionId = .newId()) {
        self.client = client
        self.featureArgs = CrossSell2.Args(
            productId: productId,
            price: price
        )
        self.impressionId = impressionId
    }

    // MARK: Feature request

    @MainActor
    func requestFeature() async {
        let _feature = CrossSell2(
            productId: self.featureArgs.productId, 
            price: self.featureArgs.price
        )

        self.state = .loading
        let result = await client.requestFeature(_feature, impressionId: self.impressionId)

        if result == nil {
            self.feature = _feature
            switch _feature.status {
                case let .on(outputs):
                    self.state = .on(outputs: outputs)
                case .off:
                    self.state = .off
                case .unrequested:
                    self.state = .loading
            }            
        } else {
            // In the event of an error requesting the feature show default values.
            // Note: Signaled events from this render will be dropped.
            self.state = .on(outputs: CrossSell2.Outputs.defaultValues)
        }
    }

    // MARK: Events

    func signal(event: CrossSell2.Event, onError: ((Error) -> Void)? = nil) {
        guard let feature else { 
            onError?(ViewModelError.missingFeature)
            return
        }

        guard let featureEvent = feature.event(event) else {
            onError?(ViewModelError.missingFeatureEvent)
            return            
        }

        Task {
            do {
                try await client.signalAndWait(featureEvent: featureEvent)
            } catch {
                onError?(error)
            }
        }
    }
}

// MARK: - CrossSellDefaultOff



final class CrossSellDefaultOff: FeatureProtocol {
    struct Outputs: FeatureOutputsProtocol, Codable, Hashable {
        let baseOnly: String

        let customerData: CustomerData

        let crosssellProductids: [String]

        let _impressionId: ImpressionId?

        fileprivate init(baseOnly: String = "base", customerData: CustomerData = CustomerData(zip: "02445", productViews: 1, lastViews: ["123", "456"]), crosssellProductids: [String] = ["60745"], _impressionId: ImpressionId? = nil) {
            self.baseOnly = baseOnly
            self.customerData = customerData
            self.crosssellProductids = crosssellProductids
            self._impressionId = _impressionId
        }

        fileprivate func with(impressionId: ImpressionId) -> Outputs {
            Outputs(
                baseOnly: self.baseOnly,
                customerData: self.customerData,
                crosssellProductids: self.crosssellProductids,
                _impressionId: impressionId
            )
        }

        static let defaultValues = Outputs()
    }

    struct Args: Codable, Hashable {
        /// The locationid for the source product in an item based collaborative filter
        let productId: String

        let price: Price?

    }

    static let name = "CrossSellDefaultOff"

    /// Feature arguments
    private(set) var args: Args

    /// The status of the feature
    private(set) var status: FeatureStatus<Outputs> = .unrequested

    // MARK: Init

    init(productId: String, price: Price? = nil) {
        self.args = Args(productId: productId, price: price)
    }

    fileprivate init(args: Args) {
        self.args = args
    }

    // MARK: FeatureProtocol

    var id: FeatureId {
        generateIdFrom(name: "CrossSellDefaultOff", args: self.args)
    }

    func update(request: FeatureUpdateRequest) throws {
        switch request {
        case .off:
             self.status = .off

        case let .on(outputJson, impressionId):
            let cachedOutputs = try decodeObject(from: outputJson, to: Outputs.self)

            if let impressionId {
                let outputsWithImpressionId = cachedOutputs.with(impressionId: impressionId)
                 self.status = .on(outputs: outputsWithImpressionId)
            } else {
                 self.status = .on(outputs: cachedOutputs)
            }
        }
    }

    func event(_ event: Event) -> FeatureEventPayload? {
        guard case let .on(outputs) = status, let impressionId = outputs._impressionId else {
            // Attempting to generate an event for a feature that is not active or doesn't have an associated impression id.
            return nil
        }

        return (event.eventDetails, impressionId)
    }

    func clone() -> CrossSellDefaultOff {
        let copy = CrossSellDefaultOff(args: self.args)
        copy.status = self.status
        return copy
    }
}

extension CrossSellDefaultOff: Equatable {
    public static func == (left: CrossSellDefaultOff, right: CrossSellDefaultOff) -> Bool {
        left.args == right.args && left.status == right.status
    }
}

// MARK: CrossSellDefaultOff Events

extension CrossSellDefaultOff {
    /// Details all possible session events
    enum Event: FeatureEventProvider {

        case crossSellClick(productId: String)

        var eventDetails: any FeatureEvent {
            switch self {
                case .crossSellClick(let productId):
                    return CrossSellClick(productId: productId)
            }
        }

        struct CrossSellClick: FeatureEvent {
            /// The name of the feature for which this event is associated.
            public static let featureName = "CrossSellDefaultOff"

            /// The name of this event.
            public static let name = "CrossSellClick"

            var productId: String

            func serialized() throws -> JSONObject {
                let json = try encodeObject(self)
                return json
            }
        }
    }
}

// MARK: - CrossSellDefaultOff View Model

final class CrossSellDefaultOffViewModel: ObservableObject, FeatureViewModel {

    /// Describes error states for this view model.
    enum ViewModelError: Swift.Error {
        /// Indicates that the `feature` was not successfully requested.
        case missingFeature

        /// Indicates that the `FeatureEventPayload` was not successfully generated.
        /// This normally happens if the feature is `off` or hasn't been successfully 
        /// requested yet.
        case missingFeatureEvent
    }

    enum State: Equatable {
        /// The requested feature is not active and should not be rendered.
        case off

        /// The requested feature is currently being fetched.
        case loading

        /// The requested feature has been loaded, is active, and is ready to be rendered.
        /// - Parameter outputs: The loaded feature outputs.
        case on(outputs: CrossSellDefaultOff.Outputs)
    }

    private var feature: CrossSellDefaultOff?
    @Published private(set) var state: State = .loading

    private let client: CausalClientProtocol
    private let featureArgs: CrossSellDefaultOff.Args
    private let impressionId: ImpressionId

    // MARK: Init

    init(client: CausalClientProtocol = CausalClient.shared, productId: String, price: Price? = nil, impressionId: ImpressionId = .newId()) {
        self.client = client
        self.featureArgs = CrossSellDefaultOff.Args(
            productId: productId,
            price: price
        )
        self.impressionId = impressionId
    }

    // MARK: Feature request

    @MainActor
    func requestFeature() async {
        let _feature = CrossSellDefaultOff(
            productId: self.featureArgs.productId, 
            price: self.featureArgs.price
        )

        self.state = .loading
        let result = await client.requestFeature(_feature, impressionId: self.impressionId)

        if result == nil {
            self.feature = _feature
            switch _feature.status {
                case let .on(outputs):
                    self.state = .on(outputs: outputs)
                case .off:
                    self.state = .off
                case .unrequested:
                    self.state = .loading
            }            
        } else {
            // In the event of an error requesting the feature show default values.
            // Note: Signaled events from this render will be dropped.
            self.state = .on(outputs: CrossSellDefaultOff.Outputs.defaultValues)
        }
    }

    // MARK: Events

    func signal(event: CrossSellDefaultOff.Event, onError: ((Error) -> Void)? = nil) {
        guard let feature else { 
            onError?(ViewModelError.missingFeature)
            return
        }

        guard let featureEvent = feature.event(event) else {
            onError?(ViewModelError.missingFeatureEvent)
            return            
        }

        Task {
            do {
                try await client.signalAndWait(featureEvent: featureEvent)
            } catch {
                onError?(error)
            }
        }
    }
}

// MARK: - Test



final class Test: FeatureProtocol {
    struct Outputs: FeatureOutputsProtocol, Codable, Hashable {
        let obj1Out: TopLevelObject

        let obj2Out: TopLevelObject?

        let float1Out: Double

        let float2Out: Double?

        let enum1Out: Color

        let enum2Out: Color?

        let string1Out: String

        let string2Out: String?

        let int1Out: Int

        let int2Out: Int?

        let _impressionId: ImpressionId?

        fileprivate init(obj1Out: TopLevelObject = TopLevelObject(float1: 1.0, float2: nil, enum1: .PRIMARY, enum2: nil, string1: "ABC", string2: nil, int1: 1, int2: nil, nested1: NestedObject(float1: 11.0, int1: -1), nested2: nil), obj2Out: TopLevelObject? = nil, float1Out: Double = 1.0, float2Out: Double? = nil, enum1Out: Color = .PRIMARY, enum2Out: Color? = nil, string1Out: String = "", string2Out: String? = nil, int1Out: Int = 0, int2Out: Int? = nil, _impressionId: ImpressionId? = nil) {
            self.obj1Out = obj1Out
            self.obj2Out = obj2Out
            self.float1Out = float1Out
            self.float2Out = float2Out
            self.enum1Out = enum1Out
            self.enum2Out = enum2Out
            self.string1Out = string1Out
            self.string2Out = string2Out
            self.int1Out = int1Out
            self.int2Out = int2Out
            self._impressionId = _impressionId
        }

        fileprivate func with(impressionId: ImpressionId) -> Outputs {
            Outputs(
                obj1Out: self.obj1Out,
                obj2Out: self.obj2Out,
                float1Out: self.float1Out,
                float2Out: self.float2Out,
                enum1Out: self.enum1Out,
                enum2Out: self.enum2Out,
                string1Out: self.string1Out,
                string2Out: self.string2Out,
                int1Out: self.int1Out,
                int2Out: self.int2Out,
                _impressionId: impressionId
            )
        }

        static let defaultValues = Outputs()
    }

    struct Args: Codable, Hashable {
        let obj1: TopLevelObject

        let obj2: TopLevelObject?

        let obj3: TopLevelObject?

        let float1: Double

        let float2: Double?

        let enum1: Color

        let enum2: Color?

        let string1: String

        let string2: String?

        let int1: Int

        let int2: Int?

    }

    static let name = "Test"

    /// Feature arguments
    private(set) var args: Args

    /// The status of the feature
    private(set) var status: FeatureStatus<Outputs> = .unrequested

    // MARK: Init

    init(obj1: TopLevelObject, obj2: TopLevelObject? = nil, obj3: TopLevelObject? = TopLevelObject(float1: 2.0, float2: nil, enum1: .SECONDARY, enum2: nil, string1: "FOO", string2: nil, int1: 4, int2: nil, nested1: NestedObject(float1: 3.0, int1: 7), nested2: nil), float1: Double = 0.0, float2: Double? = nil, enum1: Color = .PRIMARY, enum2: Color? = nil, string1: String = "", string2: String? = nil, int1: Int = 0, int2: Int? = nil) {
        self.args = Args(obj1: obj1, obj2: obj2, obj3: obj3, float1: float1, float2: float2, enum1: enum1, enum2: enum2, string1: string1, string2: string2, int1: int1, int2: int2)
    }

    fileprivate init(args: Args) {
        self.args = args
    }

    // MARK: FeatureProtocol

    var id: FeatureId {
        generateIdFrom(name: "Test", args: self.args)
    }

    func update(request: FeatureUpdateRequest) throws {
        switch request {
        case .off:
             self.status = .off

        case let .on(outputJson, impressionId):
            let cachedOutputs = try decodeObject(from: outputJson, to: Outputs.self)

            if let impressionId {
                let outputsWithImpressionId = cachedOutputs.with(impressionId: impressionId)
                 self.status = .on(outputs: outputsWithImpressionId)
            } else {
                 self.status = .on(outputs: cachedOutputs)
            }
        }
    }

    func event(_ event: Event) -> FeatureEventPayload? {
        guard case let .on(outputs) = status, let impressionId = outputs._impressionId else {
            // Attempting to generate an event for a feature that is not active or doesn't have an associated impression id.
            return nil
        }

        return (event.eventDetails, impressionId)
    }

    func clone() -> Test {
        let copy = Test(args: self.args)
        copy.status = self.status
        return copy
    }
}

extension Test: Equatable {
    public static func == (left: Test, right: Test) -> Bool {
        left.args == right.args && left.status == right.status
    }
}

// MARK: Test Events

extension Test {
    /// Details all possible session events
    enum Event: FeatureEventProvider {

        case click(obj1: TopLevelObject, obj2: TopLevelObject? = nil, float1: Double = 0.0, float2: Double? = nil, enum1: Color = .PRIMARY, enum2: Color? = nil, string1: String = "", string2: String? = nil, int1: Int = 0, int2: Int? = nil)

        var eventDetails: any FeatureEvent {
            switch self {
                case .click(let obj1, let obj2, let float1, let float2, let enum1, let enum2, let string1, let string2, let int1, let int2):
                    return Click(obj1: obj1, obj2: obj2, float1: float1, float2: float2, enum1: enum1, enum2: enum2, string1: string1, string2: string2, int1: int1, int2: int2)
            }
        }

        struct Click: FeatureEvent {
            /// The name of the feature for which this event is associated.
            public static let featureName = "Test"

            /// The name of this event.
            public static let name = "Click"

            var obj1: TopLevelObject

            var obj2: TopLevelObject?

            var float1: Double

            var float2: Double?

            var enum1: Color

            var enum2: Color?

            var string1: String

            var string2: String?

            var int1: Int

            var int2: Int?

            func serialized() throws -> JSONObject {
                let json = try encodeObject(self)
                return json
            }
        }
    }
}

// MARK: - Test View Model

final class TestViewModel: ObservableObject, FeatureViewModel {

    /// Describes error states for this view model.
    enum ViewModelError: Swift.Error {
        /// Indicates that the `feature` was not successfully requested.
        case missingFeature

        /// Indicates that the `FeatureEventPayload` was not successfully generated.
        /// This normally happens if the feature is `off` or hasn't been successfully 
        /// requested yet.
        case missingFeatureEvent
    }

    enum State: Equatable {
        /// The requested feature is not active and should not be rendered.
        case off

        /// The requested feature is currently being fetched.
        case loading

        /// The requested feature has been loaded, is active, and is ready to be rendered.
        /// - Parameter outputs: The loaded feature outputs.
        case on(outputs: Test.Outputs)
    }

    private var feature: Test?
    @Published private(set) var state: State = .loading

    private let client: CausalClientProtocol
    private let featureArgs: Test.Args
    private let impressionId: ImpressionId

    // MARK: Init

    init(client: CausalClientProtocol = CausalClient.shared, obj1: TopLevelObject, obj2: TopLevelObject? = nil, obj3: TopLevelObject? = TopLevelObject(float1: 2.0, float2: nil, enum1: .SECONDARY, enum2: nil, string1: "FOO", string2: nil, int1: 4, int2: nil, nested1: NestedObject(float1: 3.0, int1: 7), nested2: nil), float1: Double = 0.0, float2: Double? = nil, enum1: Color = .PRIMARY, enum2: Color? = nil, string1: String = "", string2: String? = nil, int1: Int = 0, int2: Int? = nil, impressionId: ImpressionId = .newId()) {
        self.client = client
        self.featureArgs = Test.Args(
            obj1: obj1,
            obj2: obj2,
            obj3: obj3,
            float1: float1,
            float2: float2,
            enum1: enum1,
            enum2: enum2,
            string1: string1,
            string2: string2,
            int1: int1,
            int2: int2
        )
        self.impressionId = impressionId
    }

    // MARK: Feature request

    @MainActor
    func requestFeature() async {
        let _feature = Test(
            obj1: self.featureArgs.obj1, 
            obj2: self.featureArgs.obj2, 
            obj3: self.featureArgs.obj3, 
            float1: self.featureArgs.float1, 
            float2: self.featureArgs.float2, 
            enum1: self.featureArgs.enum1, 
            enum2: self.featureArgs.enum2, 
            string1: self.featureArgs.string1, 
            string2: self.featureArgs.string2, 
            int1: self.featureArgs.int1, 
            int2: self.featureArgs.int2
        )

        self.state = .loading
        let result = await client.requestFeature(_feature, impressionId: self.impressionId)

        if result == nil {
            self.feature = _feature
            switch _feature.status {
                case let .on(outputs):
                    self.state = .on(outputs: outputs)
                case .off:
                    self.state = .off
                case .unrequested:
                    self.state = .loading
            }            
        } else {
            // In the event of an error requesting the feature show default values.
            // Note: Signaled events from this render will be dropped.
            self.state = .on(outputs: Test.Outputs.defaultValues)
        }
    }

    // MARK: Events

    func signal(event: Test.Event, onError: ((Error) -> Void)? = nil) {
        guard let feature else { 
            onError?(ViewModelError.missingFeature)
            return
        }

        guard let featureEvent = feature.event(event) else {
            onError?(ViewModelError.missingFeatureEvent)
            return            
        }

        Task {
            do {
                try await client.signalAndWait(featureEvent: featureEvent)
            } catch {
                onError?(error)
            }
        }
    }
}

// MARK: - BaseFeature1



// MARK: - DerivedFeature



final class DerivedFeature: FeatureProtocol {
    struct Outputs: FeatureOutputsProtocol, Codable, Hashable {
        let out1: String

        let out2: Int

        let _impressionId: ImpressionId?

        fileprivate init(out1: String = "", out2: Int = 0, _impressionId: ImpressionId? = nil) {
            self.out1 = out1
            self.out2 = out2
            self._impressionId = _impressionId
        }

        fileprivate func with(impressionId: ImpressionId) -> Outputs {
            Outputs(
                out1: self.out1,
                out2: self.out2,
                _impressionId: impressionId
            )
        }

        static let defaultValues = Outputs()
    }

    struct Args: Codable, Hashable {
        let arg1: String

        let arg2: Int

    }

    static let name = "DerivedFeature"

    /// Feature arguments
    private(set) var args: Args

    /// The status of the feature
    private(set) var status: FeatureStatus<Outputs> = .unrequested

    // MARK: Init

    init(arg1: String, arg2: Int) {
        self.args = Args(arg1: arg1, arg2: arg2)
    }

    fileprivate init(args: Args) {
        self.args = args
    }

    // MARK: FeatureProtocol

    var id: FeatureId {
        generateIdFrom(name: "DerivedFeature", args: self.args)
    }

    func update(request: FeatureUpdateRequest) throws {
        switch request {
        case .off:
             self.status = .off

        case let .on(outputJson, impressionId):
            let cachedOutputs = try decodeObject(from: outputJson, to: Outputs.self)

            if let impressionId {
                let outputsWithImpressionId = cachedOutputs.with(impressionId: impressionId)
                 self.status = .on(outputs: outputsWithImpressionId)
            } else {
                 self.status = .on(outputs: cachedOutputs)
            }
        }
    }

    func event(_ event: Event) -> FeatureEventPayload? {
        guard case let .on(outputs) = status, let impressionId = outputs._impressionId else {
            // Attempting to generate an event for a feature that is not active or doesn't have an associated impression id.
            return nil
        }

        return (event.eventDetails, impressionId)
    }

    func clone() -> DerivedFeature {
        let copy = DerivedFeature(args: self.args)
        copy.status = self.status
        return copy
    }
}

extension DerivedFeature: Equatable {
    public static func == (left: DerivedFeature, right: DerivedFeature) -> Bool {
        left.args == right.args && left.status == right.status
    }
}

// MARK: DerivedFeature Events

extension DerivedFeature {
    /// Details all possible session events
    enum Event: FeatureEventProvider {

        var eventDetails: any FeatureEvent {
            switch self {
            }
        }
    }
}

// MARK: - DerivedFeature View Model

final class DerivedFeatureViewModel: ObservableObject, FeatureViewModel {

    /// Describes error states for this view model.
    enum ViewModelError: Swift.Error {
        /// Indicates that the `feature` was not successfully requested.
        case missingFeature

        /// Indicates that the `FeatureEventPayload` was not successfully generated.
        /// This normally happens if the feature is `off` or hasn't been successfully 
        /// requested yet.
        case missingFeatureEvent
    }

    enum State: Equatable {
        /// The requested feature is not active and should not be rendered.
        case off

        /// The requested feature is currently being fetched.
        case loading

        /// The requested feature has been loaded, is active, and is ready to be rendered.
        /// - Parameter outputs: The loaded feature outputs.
        case on(outputs: DerivedFeature.Outputs)
    }

    private var feature: DerivedFeature?
    @Published private(set) var state: State = .loading

    private let client: CausalClientProtocol
    private let featureArgs: DerivedFeature.Args
    private let impressionId: ImpressionId

    // MARK: Init

    init(client: CausalClientProtocol = CausalClient.shared, arg1: String, arg2: Int, impressionId: ImpressionId = .newId()) {
        self.client = client
        self.featureArgs = DerivedFeature.Args(
            arg1: arg1,
            arg2: arg2
        )
        self.impressionId = impressionId
    }

    // MARK: Feature request

    @MainActor
    func requestFeature() async {
        let _feature = DerivedFeature(
            arg1: self.featureArgs.arg1, 
            arg2: self.featureArgs.arg2
        )

        self.state = .loading
        let result = await client.requestFeature(_feature, impressionId: self.impressionId)

        if result == nil {
            self.feature = _feature
            switch _feature.status {
                case let .on(outputs):
                    self.state = .on(outputs: outputs)
                case .off:
                    self.state = .off
                case .unrequested:
                    self.state = .loading
            }            
        } else {
            // In the event of an error requesting the feature show default values.
            // Note: Signaled events from this render will be dropped.
            self.state = .on(outputs: DerivedFeature.Outputs.defaultValues)
        }
    }

    // MARK: Events

    func signal(event: DerivedFeature.Event, onError: ((Error) -> Void)? = nil) {
        guard let feature else { 
            onError?(ViewModelError.missingFeature)
            return
        }

        guard let featureEvent = feature.event(event) else {
            onError?(ViewModelError.missingFeatureEvent)
            return            
        }

        Task {
            do {
                try await client.signalAndWait(featureEvent: featureEvent)
            } catch {
                onError?(error)
            }
        }
    }
}

// MARK: - WithSameNameOutput



final class WithSameNameOutput: FeatureProtocol {
    struct Outputs: FeatureOutputsProtocol, Codable, Hashable {
        let Color: Color?

        let _impressionId: ImpressionId?

        fileprivate init(Color: Color? = .PRIMARY, _impressionId: ImpressionId? = nil) {
            self.Color = Color
            self._impressionId = _impressionId
        }

        fileprivate func with(impressionId: ImpressionId) -> Outputs {
            Outputs(
                Color: self.Color,
                _impressionId: impressionId
            )
        }

        static let defaultValues = Outputs()
    }

    struct Args: Codable, Hashable {
    }

    static let name = "WithSameNameOutput"

    /// Feature arguments
    private(set) var args: Args

    /// The status of the feature
    private(set) var status: FeatureStatus<Outputs> = .unrequested

    // MARK: Init

    init() {
        self.args = Args()
    }

    fileprivate init(args: Args) {
        self.args = args
    }

    // MARK: FeatureProtocol

    var id: FeatureId {
        generateIdFrom(name: "WithSameNameOutput", args: self.args)
    }

    func update(request: FeatureUpdateRequest) throws {
        switch request {
        case .off:
             self.status = .off

        case let .on(outputJson, impressionId):
            let cachedOutputs = try decodeObject(from: outputJson, to: Outputs.self)

            if let impressionId {
                let outputsWithImpressionId = cachedOutputs.with(impressionId: impressionId)
                 self.status = .on(outputs: outputsWithImpressionId)
            } else {
                 self.status = .on(outputs: cachedOutputs)
            }
        }
    }

    func event(_ event: Event) -> FeatureEventPayload? {
        guard case let .on(outputs) = status, let impressionId = outputs._impressionId else {
            // Attempting to generate an event for a feature that is not active or doesn't have an associated impression id.
            return nil
        }

        return (event.eventDetails, impressionId)
    }

    func clone() -> WithSameNameOutput {
        let copy = WithSameNameOutput(args: self.args)
        copy.status = self.status
        return copy
    }
}

extension WithSameNameOutput: Equatable {
    public static func == (left: WithSameNameOutput, right: WithSameNameOutput) -> Bool {
        left.args == right.args && left.status == right.status
    }
}

// MARK: WithSameNameOutput Events

extension WithSameNameOutput {
    /// Details all possible session events
    enum Event: FeatureEventProvider {

        var eventDetails: any FeatureEvent {
            switch self {
            }
        }
    }
}

// MARK: - WithSameNameOutput View Model

final class WithSameNameOutputViewModel: ObservableObject, FeatureViewModel {

    /// Describes error states for this view model.
    enum ViewModelError: Swift.Error {
        /// Indicates that the `feature` was not successfully requested.
        case missingFeature

        /// Indicates that the `FeatureEventPayload` was not successfully generated.
        /// This normally happens if the feature is `off` or hasn't been successfully 
        /// requested yet.
        case missingFeatureEvent
    }

    enum State: Equatable {
        /// The requested feature is not active and should not be rendered.
        case off

        /// The requested feature is currently being fetched.
        case loading

        /// The requested feature has been loaded, is active, and is ready to be rendered.
        /// - Parameter outputs: The loaded feature outputs.
        case on(outputs: WithSameNameOutput.Outputs)
    }

    private var feature: WithSameNameOutput?
    @Published private(set) var state: State = .loading

    private let client: CausalClientProtocol
    private let featureArgs: WithSameNameOutput.Args
    private let impressionId: ImpressionId

    // MARK: Init

    init(client: CausalClientProtocol = CausalClient.shared, impressionId: ImpressionId = .newId()) {
        self.client = client
        self.featureArgs = WithSameNameOutput.Args(
        )
        self.impressionId = impressionId
    }

    // MARK: Feature request

    @MainActor
    func requestFeature() async {
        let _feature = WithSameNameOutput(
        )

        self.state = .loading
        let result = await client.requestFeature(_feature, impressionId: self.impressionId)

        if result == nil {
            self.feature = _feature
            switch _feature.status {
                case let .on(outputs):
                    self.state = .on(outputs: outputs)
                case .off:
                    self.state = .off
                case .unrequested:
                    self.state = .loading
            }            
        } else {
            // In the event of an error requesting the feature show default values.
            // Note: Signaled events from this render will be dropped.
            self.state = .on(outputs: WithSameNameOutput.Outputs.defaultValues)
        }
    }

    // MARK: Events

    func signal(event: WithSameNameOutput.Event, onError: ((Error) -> Void)? = nil) {
        guard let feature else { 
            onError?(ViewModelError.missingFeature)
            return
        }

        guard let featureEvent = feature.event(event) else {
            onError?(ViewModelError.missingFeatureEvent)
            return            
        }

        Task {
            do {
                try await client.signalAndWait(featureEvent: featureEvent)
            } catch {
                onError?(error)
            }
        }
    }
}


// swiftformat:enable all
// swiftlint:enable all
