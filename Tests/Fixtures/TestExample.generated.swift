// DO NOT EDIT -- file automatically generated by CausalLabsSDK.
// https://www.causallabs.io

// swiftformat:disable all
// swiftlint:disable all

import CausalLabsSDK
import Foundation
import SwiftUI

private func encodeObject<T: Codable>(_ object: T) throws -> JSONObject {
    let data = try JSONEncoder().encode(object)
    let jsonObject = try JSONSerialization.jsonObject(with: data) as? JSONObject
    return jsonObject ?? [:]
}

private func decodeObject<T: Codable>(from jsonObject: JSONObject, to type: T.Type) throws -> T {
    let data = try JSONSerialization.data(withJSONObject: jsonObject)
    return try JSONDecoder().decode(T.self, from: data)
}

private struct _IdObject<T: Codable>: Codable {
    var name: String
    var args: T
}

private func generateIdFrom<T: Codable>(name: String, args: T) -> String {
    let encoder = JSONEncoder()
    encoder.outputFormatting = [.sortedKeys]

    let idObject = _IdObject(name: name, args: args)
    if let jsonData = try? encoder.encode(idObject),
       let id = String(data: jsonData, encoding: .utf8) {
        return id
    }
    return "invalidFeatureId"
}

// MARK: - Currency

/// Class that is used to represent a currency amount
/// @deprecated Do not use this. Money is evil.
@available(*, deprecated, message: "Do not use this. Money is evil.")
enum Currency: String, Hashable, Codable {
    /// United States Dollars
    /// @deprecated Unite socialist democrats!!
    @available(*, deprecated, message: "Unite socialist democrats!!")
    case USD
    /// Euros
    case EUR
}

// MARK: - Color

/// A color enum.
enum Color: String, Hashable, Codable {
    case PRIMARY
    case SECONDARY
    case WARNING
    case ERROR
}


// MARK: - ImpressionTime

struct ImpressionTime: Hashable, Codable {
    var impressionId: String

    var impressionTime: Int

}
// MARK: - Price

/// Defines a product price.
struct Price: Hashable, Codable {
    /// The currency type.
    /// @deprecated deprecate
    @available(*, deprecated, message: "deprecate")
    var currency: Currency

    /// The amount.
    var amount: Double

}
// MARK: - CustomerData

struct CustomerData: Hashable, Codable {
    var zip: String

    var productViews: Int

    var lastViews: [String]

}
// MARK: - NestedObject

struct NestedObject: Hashable, Codable {
    var float1: Double

    var int1: Int

}
// MARK: - TopLevelObject

struct TopLevelObject: Hashable, Codable {
    var float1: Double

    var float2: Double?

    var enum1: Color

    var enum2: Color?

    var string1: String

    var string2: String?

    var int1: Int

    var int2: Int?

    var nested1: NestedObject

    var nested2: NestedObject?

}
// MARK: - DumbObject

struct DumbObject: Hashable, Codable {
    var a: Int

}

// MARK: - Session

private struct _SessionOutputs: Codable, Hashable {
}

private struct _SessionArgs: Codable, Hashable {
    var deviceId: String?
    var arrivalKey: String?
    var userId: String?
    var required: Int?
    var optional: String?
    var withDefault: String?
}

private struct _SessionKeys: Codable, Hashable {
    var deviceId: String?
    var arrivalKey: String?
}


struct Session: SessionProtocol {
    var persistentId: DeviceId? {
        self.deviceId
    }

    // MARK: Arguments

    private var _args: _SessionArgs

    var deviceId: String? {
        _args.deviceId
    }

    var arrivalKey: String? {
        _args.arrivalKey
    }

    var userId: String? {
        _args.userId
    }

    var required: Int? {
        _args.required
    }

    var optional: String? {
        _args.optional
    }

    var withDefault: String? {
        _args.withDefault
    }

    // MARK: Outputs

    private var _outputs: _SessionOutputs = _SessionOutputs()


    init(deviceId: String, arrivalKey: String? = nil, userId: String? = nil, required: Int, optional: String? = nil, withDefault: String? = "a default value") {
        self._args = _SessionArgs(deviceId:deviceId, arrivalKey:arrivalKey, userId:userId, required:required, optional:optional, withDefault:withDefault)
    }

    var id: SessionId {
        generateIdFrom(name: "session", args: self._args)
    }

    func keys() throws -> JSONObject {
        let keys = _SessionKeys(deviceId:_args.deviceId, arrivalKey:_args.arrivalKey)
        return try encodeObject(keys)
    }

    func args() throws -> JSONObject {
        try encodeObject(self._args)
    }

    mutating func updateFrom(json: JSONObject) throws {
        self._outputs = try decodeObject(from: json, to: _SessionOutputs.self)
    }
}

extension Session {
    private init(_args: _SessionArgs) {
        self._args = _args
    }

    static func fromDeviceId(_ deviceId: String) -> Session {
        Session(_args: _SessionArgs(deviceId: deviceId))
    }

    static func fromArrivalKey(_ arrivalKey: String) -> Session {
        Session(_args: _SessionArgs(arrivalKey: arrivalKey))
    }

}

// MARK: Session Events

// MARK: - TrackUser
extension Session {
    struct TrackUser: EventProtocol {
        static let featureName = "session"

        /// The name of this event.
        static let name = "TrackUser"

        // MARK: Inputs

        var timestamp: Int

        func serialized() throws -> JSONObject {
            let json = try encodeObject(self)
            return json
        }
    }

    func signalAndWaitTrackUser(client: CausalClient = .shared, timestamp: Int) async throws {
        let event = TrackUser(timestamp: timestamp)
        try await client.signalAndWait(
            event: event,
            impressionId: nil
        )
    }

    func signalTrackUser(timestamp: Int) {
        let event = TrackUser(timestamp: timestamp)
        CausalClient.shared.signalEvent(
            event,
            impressionId: nil
        )
    }
}
// MARK: - AddToCart
extension Session {
    /// The user has added a productid to the cart
    struct AddToCart: EventProtocol {
        static let featureName = "session"

        /// The name of this event.
        static let name = "AddToCart"

        // MARK: Inputs

        var productid: String

        var price: Price?

        func serialized() throws -> JSONObject {
            let json = try encodeObject(self)
            return json
        }
    }

    /// - Parameter productid: 
    /// - Parameter price: 
    /// - Throws: A ``CausalError``.
    func signalAndWaitAddToCart(client: CausalClient = .shared, productid: String, price: Price? = nil) async throws {
        let event = AddToCart(productid: productid, price: price)
        try await client.signalAndWait(
            event: event,
            impressionId: nil
        )
    }

    /// - Parameter productid: 
    /// - Parameter price: 
    func signalAddToCart(productid: String, price: Price? = nil) {
        let event = AddToCart(productid: productid, price: price)
        CausalClient.shared.signalEvent(
            event,
            impressionId: nil
        )
    }
}
// MARK: - AddToCart2
extension Session {
    /// 
    /// @deprecated for some reason
    @available(*, deprecated, message: "for some reason")
    struct AddToCart2: EventProtocol {
        static let featureName = "session"

        /// The name of this event.
        static let name = "AddToCart2"

        // MARK: Inputs

        var productid: String

        var price: Price?

        func serialized() throws -> JSONObject {
            let json = try encodeObject(self)
            return json
        }
    }

    /// - Parameter productid: 
    /// - Parameter price: 
    /// - Throws: A ``CausalError``.
    @available(*, deprecated, message: "for some reason")
    func signalAndWaitAddToCart2(client: CausalClient = .shared, productid: String, price: Price? = nil) async throws {
        let event = AddToCart2(productid: productid, price: price)
        try await client.signalAndWait(
            event: event,
            impressionId: nil
        )
    }

    /// - Parameter productid: 
    /// - Parameter price: 
    @available(*, deprecated, message: "for some reason")
    func signalAddToCart2(productid: String, price: Price? = nil) {
        let event = AddToCart2(productid: productid, price: price)
        CausalClient.shared.signalEvent(
            event,
            impressionId: nil
        )
    }
}
// MARK: - EventZ
extension Session {
    struct EventZ: EventProtocol {
        static let featureName = "session"

        /// The name of this event.
        static let name = "EventZ"

        // MARK: Inputs

        var anInt: Int?

        func serialized() throws -> JSONObject {
            let json = try encodeObject(self)
            return json
        }
    }

    func signalAndWaitEventZ(client: CausalClient = .shared, anInt: Int? = 11) async throws {
        let event = EventZ(anInt: anInt)
        try await client.signalAndWait(
            event: event,
            impressionId: nil
        )
    }

    func signalEventZ(anInt: Int? = 11) {
        let event = EventZ(anInt: anInt)
        CausalClient.shared.signalEvent(
            event,
            impressionId: nil
        )
    }
}

// MARK: - RatingBox

private struct _RatingBoxOutputs: Codable, Hashable {
    var callToAction: String = "Rate this product!"
    var actionButton: String = "Send Review"
    var impressionIds: [ImpressionId] = []
}

private struct _RatingBoxArgs: Codable, Hashable {
    var productName: String
    var productPrice: Double
    var productDescription: String?
}

/// Describes a rating box that we can put on various product pages
/// to collect ratings from our users.
final class RatingBox: FeatureProtocol {
    static let name = "RatingBox"

    var isActive = true

    var impressionIds: [ImpressionId] {
        get {
            self._outputs.impressionIds
        }
        set {
            self._outputs.impressionIds = newValue
        }
    }

    // MARK: Arguments
    private var _args: _RatingBoxArgs

    /// The product for which we are collecting ratings.
    var productName: String {
        self._args.productName
    }
    /// The price of the product for which we are collecting ratings.
    var productPrice: Double {
        self._args.productPrice
    }
    /// The description of the product, if any.
    var productDescription: String? {
        self._args.productDescription
    }

    // MARK: Outputs
    private var _outputs: _RatingBoxOutputs = _RatingBoxOutputs()

    /// The prompts for the user to rate the product.
    var callToAction: String {
        self._outputs.callToAction
    }
    /// The button text for the user submit a review.
    var actionButton: String {
        self._outputs.actionButton
    }

    // MARK: Init

    init(productName: String, productPrice: Double, productDescription: String? = nil) {
        self._args = _RatingBoxArgs(productName: productName, productPrice: productPrice, productDescription: productDescription)
    }

    private init(args: _RatingBoxArgs) {
        self._args = args
    }

    // MARK: FeatureProtocol

    var id: FeatureId {
        generateIdFrom(name: "RatingBox", args: self._args)
    }

    func args() throws -> JSONObject {
        try encodeObject(self._args)
    }

    func updateFrom(json: JSONObject) throws {
        self._outputs = try decodeObject(from: json, to: _RatingBoxOutputs.self)
    }

    func copy(newImpressionId: ImpressionId) -> RatingBox {
        let copy = RatingBox(args: self._args)
        copy._outputs = self._outputs
        copy.isActive = self.isActive
        copy.impressionIds = [newImpressionId]
        return copy
    }
}

extension RatingBox: Equatable {
    public static func == (left: RatingBox, right: RatingBox) -> Bool {
        left.isActive == right.isActive
        && left._args == right._args
        && left._outputs == right._outputs
    }
}

// MARK: RatingBox Events

// MARK: - Rating
extension RatingBox {
    /// Occurs each time a rating is collected.
    struct Rating: EventProtocol {
        /// The name of the feature for which this event is associated.
        public static let featureName = "RatingBox"

        /// The name of this event.
        public static let name = "Rating"

        /// The rating value from the user.
        var stars: Int

        func serialized() throws -> JSONObject {
            let json = try encodeObject(self)
            return json
        }
    }

    /// - Parameter stars: The rating value from the user.
    /// - Throws: A ``CausalError``.
    func signalAndWaitRating(client: CausalClient = .shared, stars: Int) async throws {
        let event = Rating(stars: stars)
        try await client.signalAndWait(
            event: event,
            impressionId: self.impressionIds.first ?? ""
        )
    }

    /// - Parameter stars: The rating value from the user.
    func signalRating(stars: Int) {
        let event = Rating(stars: stars)
        CausalClient.shared.signalEvent(
            event,
            impressionId: self.impressionIds.first ?? ""
        )
    }
}

// MARK: - RatingBox View Model

final class RatingBoxViewModel: ObservableObject, FeatureViewModel {
    @Published var feature: RatingBox?

    // MARK: Arguments

    let productName: String
    let productPrice: Double
    let productDescription: String?
    let impressionId: ImpressionId

    // MARK: Init

    init(productName: String, productPrice: Double, productDescription: String? = nil, impressionId: ImpressionId = .newId()) {
        self.productName = productName
        self.productPrice = productPrice
        self.productDescription = productDescription
        self.impressionId = impressionId
    }

    // MARK: Feature request

    @MainActor
    func requestFeature() async throws {
        let _feature = RatingBox(productName: self.productName, productPrice: self.productPrice, productDescription: self.productDescription)
        _feature.impressionIds = [self.impressionId]

        do {
            self.feature = try await CausalClient.shared.requestFeature(
                feature: _feature,
                impressionId: self.impressionId
            )
        } catch {
            self.feature = _feature
            throw error
        }
    }

    // MARK: Events

    func signalRating(stars: Int, onError: ((Error) -> Void)? = nil) {
        Task {
            do {
                try await self.feature?.signalAndWaitRating(stars: stars)
            } catch {
                onError?(error)
            }
        }
    }
}

// MARK: - ProductInfo

private struct _ProductInfoOutputs: Codable, Hashable {
    var impressionIds: [ImpressionId] = []
}

private struct _ProductInfoArgs: Codable, Hashable {
}

/// An empty feature
final class ProductInfo: FeatureProtocol {
    static let name = "ProductInfo"

    var isActive = true

    var impressionIds: [ImpressionId] {
        get {
            self._outputs.impressionIds
        }
        set {
            self._outputs.impressionIds = newValue
        }
    }

    // MARK: Arguments
    private var _args: _ProductInfoArgs


    // MARK: Outputs
    private var _outputs: _ProductInfoOutputs = _ProductInfoOutputs()


    // MARK: Init

    init() {
        self._args = _ProductInfoArgs()
    }

    private init(args: _ProductInfoArgs) {
        self._args = args
    }

    // MARK: FeatureProtocol

    var id: FeatureId {
        generateIdFrom(name: "ProductInfo", args: self._args)
    }

    func args() throws -> JSONObject {
        try encodeObject(self._args)
    }

    func updateFrom(json: JSONObject) throws {
        self._outputs = try decodeObject(from: json, to: _ProductInfoOutputs.self)
    }

    func copy(newImpressionId: ImpressionId) -> ProductInfo {
        let copy = ProductInfo(args: self._args)
        copy._outputs = self._outputs
        copy.isActive = self.isActive
        copy.impressionIds = [newImpressionId]
        return copy
    }
}

extension ProductInfo: Equatable {
    public static func == (left: ProductInfo, right: ProductInfo) -> Bool {
        left.isActive == right.isActive
        && left._args == right._args
        && left._outputs == right._outputs
    }
}

// MARK: ProductInfo Events


// MARK: - ProductInfo View Model

final class ProductInfoViewModel: ObservableObject, FeatureViewModel {
    @Published var feature: ProductInfo?

    // MARK: Arguments

    let impressionId: ImpressionId

    // MARK: Init

    init(impressionId: ImpressionId = .newId()) {
        self.impressionId = impressionId
    }

    // MARK: Feature request

    @MainActor
    func requestFeature() async throws {
        let _feature = ProductInfo()
        _feature.impressionIds = [self.impressionId]

        do {
            self.feature = try await CausalClient.shared.requestFeature(
                feature: _feature,
                impressionId: self.impressionId
            )
        } catch {
            self.feature = _feature
            throw error
        }
    }

    // MARK: Events

}

// MARK: - ProductDisplay

private struct _ProductDisplayOutputs: Codable, Hashable {
    var impressionIds: [ImpressionId] = []
}

private struct _ProductDisplayArgs: Codable, Hashable {
    var productName: String
    var price: Price
}

/// A feature with a nested object
final class ProductDisplay: FeatureProtocol {
    static let name = "ProductDisplay"

    var isActive = true

    var impressionIds: [ImpressionId] {
        get {
            self._outputs.impressionIds
        }
        set {
            self._outputs.impressionIds = newValue
        }
    }

    // MARK: Arguments
    private var _args: _ProductDisplayArgs

    /// The name.
    var productName: String {
        self._args.productName
    }
    /// TODO: This currently does not work with json handling
    var price: Price {
        self._args.price
    }

    // MARK: Outputs
    private var _outputs: _ProductDisplayOutputs = _ProductDisplayOutputs()


    // MARK: Init

    init(productName: String, price: Price) {
        self._args = _ProductDisplayArgs(productName: productName, price: price)
    }

    private init(args: _ProductDisplayArgs) {
        self._args = args
    }

    // MARK: FeatureProtocol

    var id: FeatureId {
        generateIdFrom(name: "ProductDisplay", args: self._args)
    }

    func args() throws -> JSONObject {
        try encodeObject(self._args)
    }

    func updateFrom(json: JSONObject) throws {
        self._outputs = try decodeObject(from: json, to: _ProductDisplayOutputs.self)
    }

    func copy(newImpressionId: ImpressionId) -> ProductDisplay {
        let copy = ProductDisplay(args: self._args)
        copy._outputs = self._outputs
        copy.isActive = self.isActive
        copy.impressionIds = [newImpressionId]
        return copy
    }
}

extension ProductDisplay: Equatable {
    public static func == (left: ProductDisplay, right: ProductDisplay) -> Bool {
        left.isActive == right.isActive
        && left._args == right._args
        && left._outputs == right._outputs
    }
}

// MARK: ProductDisplay Events


// MARK: - ProductDisplay View Model

final class ProductDisplayViewModel: ObservableObject, FeatureViewModel {
    @Published var feature: ProductDisplay?

    // MARK: Arguments

    let productName: String
    let price: Price
    let impressionId: ImpressionId

    // MARK: Init

    init(productName: String, price: Price, impressionId: ImpressionId = .newId()) {
        self.productName = productName
        self.price = price
        self.impressionId = impressionId
    }

    // MARK: Feature request

    @MainActor
    func requestFeature() async throws {
        let _feature = ProductDisplay(productName: self.productName, price: self.price)
        _feature.impressionIds = [self.impressionId]

        do {
            self.feature = try await CausalClient.shared.requestFeature(
                feature: _feature,
                impressionId: self.impressionId
            )
        } catch {
            self.feature = _feature
            throw error
        }
    }

    // MARK: Events

}

// MARK: - EmptyFeature

private struct _EmptyFeatureOutputs: Codable, Hashable {
    var impressionIds: [ImpressionId] = []
}

private struct _EmptyFeatureArgs: Codable, Hashable {
}

final class EmptyFeature: FeatureProtocol {
    static let name = "EmptyFeature"

    var isActive = true

    var impressionIds: [ImpressionId] {
        get {
            self._outputs.impressionIds
        }
        set {
            self._outputs.impressionIds = newValue
        }
    }

    // MARK: Arguments
    private var _args: _EmptyFeatureArgs


    // MARK: Outputs
    private var _outputs: _EmptyFeatureOutputs = _EmptyFeatureOutputs()


    // MARK: Init

    init() {
        self._args = _EmptyFeatureArgs()
    }

    private init(args: _EmptyFeatureArgs) {
        self._args = args
    }

    // MARK: FeatureProtocol

    var id: FeatureId {
        generateIdFrom(name: "EmptyFeature", args: self._args)
    }

    func args() throws -> JSONObject {
        try encodeObject(self._args)
    }

    func updateFrom(json: JSONObject) throws {
        self._outputs = try decodeObject(from: json, to: _EmptyFeatureOutputs.self)
    }

    func copy(newImpressionId: ImpressionId) -> EmptyFeature {
        let copy = EmptyFeature(args: self._args)
        copy._outputs = self._outputs
        copy.isActive = self.isActive
        copy.impressionIds = [newImpressionId]
        return copy
    }
}

extension EmptyFeature: Equatable {
    public static func == (left: EmptyFeature, right: EmptyFeature) -> Bool {
        left.isActive == right.isActive
        && left._args == right._args
        && left._outputs == right._outputs
    }
}

// MARK: EmptyFeature Events


// MARK: - EmptyFeature View Model

final class EmptyFeatureViewModel: ObservableObject, FeatureViewModel {
    @Published var feature: EmptyFeature?

    // MARK: Arguments

    let impressionId: ImpressionId

    // MARK: Init

    init(impressionId: ImpressionId = .newId()) {
        self.impressionId = impressionId
    }

    // MARK: Feature request

    @MainActor
    func requestFeature() async throws {
        let _feature = EmptyFeature()
        _feature.impressionIds = [self.impressionId]

        do {
            self.feature = try await CausalClient.shared.requestFeature(
                feature: _feature,
                impressionId: self.impressionId
            )
        } catch {
            self.feature = _feature
            throw error
        }
    }

    // MARK: Events

}

// MARK: - StrangeFeature

private struct _StrangeFeatureOutputs: Codable, Hashable {
    var impressionIds: [ImpressionId] = []
}

private struct _StrangeFeatureArgs: Codable, Hashable {
}

final class StrangeFeature: FeatureProtocol {
    static let name = "StrangeFeature"

    var isActive = true

    var impressionIds: [ImpressionId] {
        get {
            self._outputs.impressionIds
        }
        set {
            self._outputs.impressionIds = newValue
        }
    }

    // MARK: Arguments
    private var _args: _StrangeFeatureArgs


    // MARK: Outputs
    private var _outputs: _StrangeFeatureOutputs = _StrangeFeatureOutputs()


    // MARK: Init

    init() {
        self._args = _StrangeFeatureArgs()
    }

    private init(args: _StrangeFeatureArgs) {
        self._args = args
    }

    // MARK: FeatureProtocol

    var id: FeatureId {
        generateIdFrom(name: "StrangeFeature", args: self._args)
    }

    func args() throws -> JSONObject {
        try encodeObject(self._args)
    }

    func updateFrom(json: JSONObject) throws {
        self._outputs = try decodeObject(from: json, to: _StrangeFeatureOutputs.self)
    }

    func copy(newImpressionId: ImpressionId) -> StrangeFeature {
        let copy = StrangeFeature(args: self._args)
        copy._outputs = self._outputs
        copy.isActive = self.isActive
        copy.impressionIds = [newImpressionId]
        return copy
    }
}

extension StrangeFeature: Equatable {
    public static func == (left: StrangeFeature, right: StrangeFeature) -> Bool {
        left.isActive == right.isActive
        && left._args == right._args
        && left._outputs == right._outputs
    }
}

// MARK: StrangeFeature Events

// MARK: - NoParamEvent
extension StrangeFeature {
    struct NoParamEvent: EventProtocol {
        /// The name of the feature for which this event is associated.
        public static let featureName = "StrangeFeature"

        /// The name of this event.
        public static let name = "NoParamEvent"

        func serialized() throws -> JSONObject {
            let json = try encodeObject(self)
            return json
        }
    }

    func signalAndWaitNoParamEvent(client: CausalClient = .shared) async throws {
        let event = NoParamEvent()
        try await client.signalAndWait(
            event: event,
            impressionId: self.impressionIds.first ?? ""
        )
    }

    func signalNoParamEvent() {
        let event = NoParamEvent()
        CausalClient.shared.signalEvent(
            event,
            impressionId: self.impressionIds.first ?? ""
        )
    }
}

// MARK: - StrangeFeature View Model

final class StrangeFeatureViewModel: ObservableObject, FeatureViewModel {
    @Published var feature: StrangeFeature?

    // MARK: Arguments

    let impressionId: ImpressionId

    // MARK: Init

    init(impressionId: ImpressionId = .newId()) {
        self.impressionId = impressionId
    }

    // MARK: Feature request

    @MainActor
    func requestFeature() async throws {
        let _feature = StrangeFeature()
        _feature.impressionIds = [self.impressionId]

        do {
            self.feature = try await CausalClient.shared.requestFeature(
                feature: _feature,
                impressionId: self.impressionId
            )
        } catch {
            self.feature = _feature
            throw error
        }
    }

    // MARK: Events

    func signalNoParamEvent(onError: ((Error) -> Void)? = nil) {
        Task {
            do {
                try await self.feature?.signalAndWaitNoParamEvent()
            } catch {
                onError?(error)
            }
        }
    }
}

// MARK: - Commerce

private struct _CommerceOutputs: Codable, Hashable {
    var commerceButtonColor: Color = .PRIMARY
    var ctaText: String = "View Deal"
    var nullable: String? = "non null default value"
    var impressionIds: [ImpressionId] = []
}

private struct _CommerceArgs: Codable, Hashable {
}

/// Feature representing a page that contains commerce buttons
/// @deprecated reason
@available(*, deprecated, message: "reason")
final class Commerce: FeatureProtocol {
    static let name = "Commerce"

    var isActive = true

    var impressionIds: [ImpressionId] {
        get {
            self._outputs.impressionIds
        }
        set {
            self._outputs.impressionIds = newValue
        }
    }

    // MARK: Arguments
    private var _args: _CommerceArgs


    // MARK: Outputs
    private var _outputs: _CommerceOutputs = _CommerceOutputs()

    /// Material UI palette color for commerce buttons
    var commerceButtonColor: Color {
        self._outputs.commerceButtonColor
    }
    /// 
    /// @deprecated reason
    @available(*, deprecated, message: "reason")
    var ctaText: String {
        self._outputs.ctaText
    }
    var nullable: String? {
        self._outputs.nullable
    }

    // MARK: Init

    init() {
        self._args = _CommerceArgs()
    }

    private init(args: _CommerceArgs) {
        self._args = args
    }

    // MARK: FeatureProtocol

    var id: FeatureId {
        generateIdFrom(name: "Commerce", args: self._args)
    }

    func args() throws -> JSONObject {
        try encodeObject(self._args)
    }

    func updateFrom(json: JSONObject) throws {
        self._outputs = try decodeObject(from: json, to: _CommerceOutputs.self)
    }

    func copy(newImpressionId: ImpressionId) -> Commerce {
        let copy = Commerce(args: self._args)
        copy._outputs = self._outputs
        copy.isActive = self.isActive
        copy.impressionIds = [newImpressionId]
        return copy
    }
}

extension Commerce: Equatable {
    public static func == (left: Commerce, right: Commerce) -> Bool {
        left.isActive == right.isActive
        && left._args == right._args
        && left._outputs == right._outputs
    }
}

// MARK: Commerce Events

// MARK: - CommerceClick
extension Commerce {
    /// This represents a click on a commence button, leading to a partner.
    /// @deprecated I don&#39;t know why
    @available(*, deprecated, message: "I don&#39;t know why")
    struct CommerceClick: EventProtocol {
        /// The name of the feature for which this event is associated.
        public static let featureName = "Commerce"

        /// The name of this event.
        public static let name = "CommerceClick"

        var productid: String

        var price: Price?

        func serialized() throws -> JSONObject {
            let json = try encodeObject(self)
            return json
        }
    }

    /// - Parameter productid: 
    /// - Parameter price: 
    /// - Throws: A ``CausalError``.
    @available(*, deprecated, message: "I don&#39;t know why")
    func signalAndWaitCommerceClick(client: CausalClient = .shared, productid: String, price: Price?) async throws {
        let event = CommerceClick(productid: productid, price: price)
        try await client.signalAndWait(
            event: event,
            impressionId: self.impressionIds.first ?? ""
        )
    }

    /// - Parameter productid: 
    /// - Parameter price: 
    @available(*, deprecated, message: "I don&#39;t know why")
    func signalCommerceClick(productid: String, price: Price?) {
        let event = CommerceClick(productid: productid, price: price)
        CausalClient.shared.signalEvent(
            event,
            impressionId: self.impressionIds.first ?? ""
        )
    }
}

// MARK: - Commerce View Model

final class CommerceViewModel: ObservableObject, FeatureViewModel {
    @Published var feature: Commerce?

    // MARK: Arguments

    let impressionId: ImpressionId

    // MARK: Init

    init(impressionId: ImpressionId = .newId()) {
        self.impressionId = impressionId
    }

    // MARK: Feature request

    @MainActor
    func requestFeature() async throws {
        let _feature = Commerce()
        _feature.impressionIds = [self.impressionId]

        do {
            self.feature = try await CausalClient.shared.requestFeature(
                feature: _feature,
                impressionId: self.impressionId
            )
        } catch {
            self.feature = _feature
            throw error
        }
    }

    // MARK: Events

    func signalCommerceClick(productid: String, price: Price?, onError: ((Error) -> Void)? = nil) {
        Task {
            do {
                try await self.feature?.signalAndWaitCommerceClick(productid: productid, price: price)
            } catch {
                onError?(error)
            }
        }
    }
}

// MARK: - Feature_with_underscores

private struct _Feature_with_underscoresOutputs: Codable, Hashable {
    var a_value: String = "value"
    var impressionIds: [ImpressionId] = []
}

private struct _Feature_with_underscoresArgs: Codable, Hashable {
}

final class Feature_with_underscores: FeatureProtocol {
    static let name = "Feature_with_underscores"

    var isActive = true

    var impressionIds: [ImpressionId] {
        get {
            self._outputs.impressionIds
        }
        set {
            self._outputs.impressionIds = newValue
        }
    }

    // MARK: Arguments
    private var _args: _Feature_with_underscoresArgs


    // MARK: Outputs
    private var _outputs: _Feature_with_underscoresOutputs = _Feature_with_underscoresOutputs()

    var a_value: String {
        self._outputs.a_value
    }

    // MARK: Init

    init() {
        self._args = _Feature_with_underscoresArgs()
    }

    private init(args: _Feature_with_underscoresArgs) {
        self._args = args
    }

    // MARK: FeatureProtocol

    var id: FeatureId {
        generateIdFrom(name: "Feature_with_underscores", args: self._args)
    }

    func args() throws -> JSONObject {
        try encodeObject(self._args)
    }

    func updateFrom(json: JSONObject) throws {
        self._outputs = try decodeObject(from: json, to: _Feature_with_underscoresOutputs.self)
    }

    func copy(newImpressionId: ImpressionId) -> Feature_with_underscores {
        let copy = Feature_with_underscores(args: self._args)
        copy._outputs = self._outputs
        copy.isActive = self.isActive
        copy.impressionIds = [newImpressionId]
        return copy
    }
}

extension Feature_with_underscores: Equatable {
    public static func == (left: Feature_with_underscores, right: Feature_with_underscores) -> Bool {
        left.isActive == right.isActive
        && left._args == right._args
        && left._outputs == right._outputs
    }
}

// MARK: Feature_with_underscores Events


// MARK: - Feature_with_underscores View Model

final class Feature_with_underscoresViewModel: ObservableObject, FeatureViewModel {
    @Published var feature: Feature_with_underscores?

    // MARK: Arguments

    let impressionId: ImpressionId

    // MARK: Init

    init(impressionId: ImpressionId = .newId()) {
        self.impressionId = impressionId
    }

    // MARK: Feature request

    @MainActor
    func requestFeature() async throws {
        let _feature = Feature_with_underscores()
        _feature.impressionIds = [self.impressionId]

        do {
            self.feature = try await CausalClient.shared.requestFeature(
                feature: _feature,
                impressionId: self.impressionId
            )
        } catch {
            self.feature = _feature
            throw error
        }
    }

    // MARK: Events

}

// MARK: - featureThatStartsWithLowercase

private struct _featureThatStartsWithLowercaseOutputs: Codable, Hashable {
    var a_value: String = "value"
    var impressionIds: [ImpressionId] = []
}

private struct _featureThatStartsWithLowercaseArgs: Codable, Hashable {
}

final class featureThatStartsWithLowercase: FeatureProtocol {
    static let name = "featureThatStartsWithLowercase"

    var isActive = true

    var impressionIds: [ImpressionId] {
        get {
            self._outputs.impressionIds
        }
        set {
            self._outputs.impressionIds = newValue
        }
    }

    // MARK: Arguments
    private var _args: _featureThatStartsWithLowercaseArgs


    // MARK: Outputs
    private var _outputs: _featureThatStartsWithLowercaseOutputs = _featureThatStartsWithLowercaseOutputs()

    var a_value: String {
        self._outputs.a_value
    }

    // MARK: Init

    init() {
        self._args = _featureThatStartsWithLowercaseArgs()
    }

    private init(args: _featureThatStartsWithLowercaseArgs) {
        self._args = args
    }

    // MARK: FeatureProtocol

    var id: FeatureId {
        generateIdFrom(name: "featureThatStartsWithLowercase", args: self._args)
    }

    func args() throws -> JSONObject {
        try encodeObject(self._args)
    }

    func updateFrom(json: JSONObject) throws {
        self._outputs = try decodeObject(from: json, to: _featureThatStartsWithLowercaseOutputs.self)
    }

    func copy(newImpressionId: ImpressionId) -> featureThatStartsWithLowercase {
        let copy = featureThatStartsWithLowercase(args: self._args)
        copy._outputs = self._outputs
        copy.isActive = self.isActive
        copy.impressionIds = [newImpressionId]
        return copy
    }
}

extension featureThatStartsWithLowercase: Equatable {
    public static func == (left: featureThatStartsWithLowercase, right: featureThatStartsWithLowercase) -> Bool {
        left.isActive == right.isActive
        && left._args == right._args
        && left._outputs == right._outputs
    }
}

// MARK: featureThatStartsWithLowercase Events


// MARK: - featureThatStartsWithLowercase View Model

final class featureThatStartsWithLowercaseViewModel: ObservableObject, FeatureViewModel {
    @Published var feature: featureThatStartsWithLowercase?

    // MARK: Arguments

    let impressionId: ImpressionId

    // MARK: Init

    init(impressionId: ImpressionId = .newId()) {
        self.impressionId = impressionId
    }

    // MARK: Feature request

    @MainActor
    func requestFeature() async throws {
        let _feature = featureThatStartsWithLowercase()
        _feature.impressionIds = [self.impressionId]

        do {
            self.feature = try await CausalClient.shared.requestFeature(
                feature: _feature,
                impressionId: self.impressionId
            )
        } catch {
            self.feature = _feature
            throw error
        }
    }

    // MARK: Events

}

// MARK: - CrossSellRoot

private struct _CrossSellRootOutputs: Codable, Hashable {
    var baseOnly: String = "base"
    var customerData: CustomerData = CustomerData(zip: "02445", productViews: 1, lastViews: ["123", "456"])
    var impressionIds: [ImpressionId] = []
}

private struct _CrossSellRootArgs: Codable, Hashable {
}

// MARK: - CrossSell

private struct _CrossSellOutputs: Codable, Hashable {
    var baseOnly: String = "base"
    var customerData: CustomerData = CustomerData(zip: "02445", productViews: 1, lastViews: ["123", "456"])
    var crosssellProductids: [String] = ["60745"]
    var nullable: String? = "default response"
    var impressionIds: [ImpressionId] = []
}

private struct _CrossSellArgs: Codable, Hashable {
    var productId: String
    var price: Price?
    var withDefault: String?
}

final class CrossSell: FeatureProtocol {
    static let name = "CrossSell"

    var isActive = true

    var impressionIds: [ImpressionId] {
        get {
            self._outputs.impressionIds
        }
        set {
            self._outputs.impressionIds = newValue
        }
    }

    // MARK: Arguments
    private var _args: _CrossSellArgs

    /// The locationid for the source product in an item based collaborative filter
    var productId: String {
        self._args.productId
    }
    var price: Price? {
        self._args.price
    }
    var withDefault: String? {
        self._args.withDefault
    }

    // MARK: Outputs
    private var _outputs: _CrossSellOutputs = _CrossSellOutputs()

    var baseOnly: String {
        self._outputs.baseOnly
    }
    var customerData: CustomerData {
        self._outputs.customerData
    }
    var crosssellProductids: [String] {
        self._outputs.crosssellProductids
    }
    var nullable: String? {
        self._outputs.nullable
    }

    // MARK: Init

    init(productId: String, price: Price? = nil, withDefault: String? = "another default") {
        self._args = _CrossSellArgs(productId: productId, price: price, withDefault: withDefault)
    }

    private init(args: _CrossSellArgs) {
        self._args = args
    }

    // MARK: FeatureProtocol

    var id: FeatureId {
        generateIdFrom(name: "CrossSell", args: self._args)
    }

    func args() throws -> JSONObject {
        try encodeObject(self._args)
    }

    func updateFrom(json: JSONObject) throws {
        self._outputs = try decodeObject(from: json, to: _CrossSellOutputs.self)
    }

    func copy(newImpressionId: ImpressionId) -> CrossSell {
        let copy = CrossSell(args: self._args)
        copy._outputs = self._outputs
        copy.isActive = self.isActive
        copy.impressionIds = [newImpressionId]
        return copy
    }
}

extension CrossSell: Equatable {
    public static func == (left: CrossSell, right: CrossSell) -> Bool {
        left.isActive == right.isActive
        && left._args == right._args
        && left._outputs == right._outputs
    }
}

// MARK: CrossSell Events

// MARK: - CrossSellClick
extension CrossSell {
    struct CrossSellClick: EventProtocol {
        /// The name of the feature for which this event is associated.
        public static let featureName = "CrossSell"

        /// The name of this event.
        public static let name = "CrossSellClick"

        var productid: String

        func serialized() throws -> JSONObject {
            let json = try encodeObject(self)
            return json
        }
    }

    func signalAndWaitCrossSellClick(client: CausalClient = .shared, productid: String) async throws {
        let event = CrossSellClick(productid: productid)
        try await client.signalAndWait(
            event: event,
            impressionId: self.impressionIds.first ?? ""
        )
    }

    func signalCrossSellClick(productid: String) {
        let event = CrossSellClick(productid: productid)
        CausalClient.shared.signalEvent(
            event,
            impressionId: self.impressionIds.first ?? ""
        )
    }
}
// MARK: - EventA
extension CrossSell {
    struct EventA: EventProtocol {
        /// The name of the feature for which this event is associated.
        public static let featureName = "CrossSell"

        /// The name of this event.
        public static let name = "EventA"

        var anInt: Int?

        func serialized() throws -> JSONObject {
            let json = try encodeObject(self)
            return json
        }
    }

    func signalAndWaitEventA(client: CausalClient = .shared, anInt: Int? = 7777) async throws {
        let event = EventA(anInt: anInt)
        try await client.signalAndWait(
            event: event,
            impressionId: self.impressionIds.first ?? ""
        )
    }

    func signalEventA(anInt: Int? = 7777) {
        let event = EventA(anInt: anInt)
        CausalClient.shared.signalEvent(
            event,
            impressionId: self.impressionIds.first ?? ""
        )
    }
}

// MARK: - CrossSell View Model

final class CrossSellViewModel: ObservableObject, FeatureViewModel {
    @Published var feature: CrossSell?

    // MARK: Arguments

    let productId: String
    let price: Price?
    let withDefault: String?
    let impressionId: ImpressionId

    // MARK: Init

    init(productId: String, price: Price? = nil, withDefault: String? = "another default", impressionId: ImpressionId = .newId()) {
        self.productId = productId
        self.price = price
        self.withDefault = withDefault
        self.impressionId = impressionId
    }

    // MARK: Feature request

    @MainActor
    func requestFeature() async throws {
        let _feature = CrossSell(productId: self.productId, price: self.price, withDefault: self.withDefault)
        _feature.impressionIds = [self.impressionId]

        do {
            self.feature = try await CausalClient.shared.requestFeature(
                feature: _feature,
                impressionId: self.impressionId
            )
        } catch {
            self.feature = _feature
            throw error
        }
    }

    // MARK: Events

    func signalCrossSellClick(productid: String, onError: ((Error) -> Void)? = nil) {
        Task {
            do {
                try await self.feature?.signalAndWaitCrossSellClick(productid: productid)
            } catch {
                onError?(error)
            }
        }
    }
    func signalEventA(anInt: Int? = 7777, onError: ((Error) -> Void)? = nil) {
        Task {
            do {
                try await self.feature?.signalAndWaitEventA(anInt: anInt)
            } catch {
                onError?(error)
            }
        }
    }
}

// MARK: - CrossSell2

private struct _CrossSell2Outputs: Codable, Hashable {
    var baseOnly: String = "base"
    var customerData: CustomerData = CustomerData(zip: "02445", productViews: 1, lastViews: ["123", "456"])
    var crosssellProductids: [String] = ["60745"]
    var two: String = "two"
    var impressionIds: [ImpressionId] = []
}

private struct _CrossSell2Args: Codable, Hashable {
    var productId: String
    var price: Price?
}

final class CrossSell2: FeatureProtocol {
    static let name = "CrossSell2"

    var isActive = true

    var impressionIds: [ImpressionId] {
        get {
            self._outputs.impressionIds
        }
        set {
            self._outputs.impressionIds = newValue
        }
    }

    // MARK: Arguments
    private var _args: _CrossSell2Args

    /// The locationid for the source product in an item based collaborative filter
    var productId: String {
        self._args.productId
    }
    var price: Price? {
        self._args.price
    }

    // MARK: Outputs
    private var _outputs: _CrossSell2Outputs = _CrossSell2Outputs()

    var baseOnly: String {
        self._outputs.baseOnly
    }
    var customerData: CustomerData {
        self._outputs.customerData
    }
    var crosssellProductids: [String] {
        self._outputs.crosssellProductids
    }
    var two: String {
        self._outputs.two
    }

    // MARK: Init

    init(productId: String, price: Price? = nil) {
        self._args = _CrossSell2Args(productId: productId, price: price)
    }

    private init(args: _CrossSell2Args) {
        self._args = args
    }

    // MARK: FeatureProtocol

    var id: FeatureId {
        generateIdFrom(name: "CrossSell2", args: self._args)
    }

    func args() throws -> JSONObject {
        try encodeObject(self._args)
    }

    func updateFrom(json: JSONObject) throws {
        self._outputs = try decodeObject(from: json, to: _CrossSell2Outputs.self)
    }

    func copy(newImpressionId: ImpressionId) -> CrossSell2 {
        let copy = CrossSell2(args: self._args)
        copy._outputs = self._outputs
        copy.isActive = self.isActive
        copy.impressionIds = [newImpressionId]
        return copy
    }
}

extension CrossSell2: Equatable {
    public static func == (left: CrossSell2, right: CrossSell2) -> Bool {
        left.isActive == right.isActive
        && left._args == right._args
        && left._outputs == right._outputs
    }
}

// MARK: CrossSell2 Events

// MARK: - CrossSellClick
extension CrossSell2 {
    struct CrossSellClick: EventProtocol {
        /// The name of the feature for which this event is associated.
        public static let featureName = "CrossSell2"

        /// The name of this event.
        public static let name = "CrossSellClick"

        var productid: String

        func serialized() throws -> JSONObject {
            let json = try encodeObject(self)
            return json
        }
    }

    func signalAndWaitCrossSellClick(client: CausalClient = .shared, productid: String) async throws {
        let event = CrossSellClick(productid: productid)
        try await client.signalAndWait(
            event: event,
            impressionId: self.impressionIds.first ?? ""
        )
    }

    func signalCrossSellClick(productid: String) {
        let event = CrossSellClick(productid: productid)
        CausalClient.shared.signalEvent(
            event,
            impressionId: self.impressionIds.first ?? ""
        )
    }
}

// MARK: - CrossSell2 View Model

final class CrossSell2ViewModel: ObservableObject, FeatureViewModel {
    @Published var feature: CrossSell2?

    // MARK: Arguments

    let productId: String
    let price: Price?
    let impressionId: ImpressionId

    // MARK: Init

    init(productId: String, price: Price? = nil, impressionId: ImpressionId = .newId()) {
        self.productId = productId
        self.price = price
        self.impressionId = impressionId
    }

    // MARK: Feature request

    @MainActor
    func requestFeature() async throws {
        let _feature = CrossSell2(productId: self.productId, price: self.price)
        _feature.impressionIds = [self.impressionId]

        do {
            self.feature = try await CausalClient.shared.requestFeature(
                feature: _feature,
                impressionId: self.impressionId
            )
        } catch {
            self.feature = _feature
            throw error
        }
    }

    // MARK: Events

    func signalCrossSellClick(productid: String, onError: ((Error) -> Void)? = nil) {
        Task {
            do {
                try await self.feature?.signalAndWaitCrossSellClick(productid: productid)
            } catch {
                onError?(error)
            }
        }
    }
}

// MARK: - CrossSellDefaultOff

private struct _CrossSellDefaultOffOutputs: Codable, Hashable {
    var baseOnly: String = "base"
    var customerData: CustomerData = CustomerData(zip: "02445", productViews: 1, lastViews: ["123", "456"])
    var crosssellProductids: [String] = ["60745"]
    var impressionIds: [ImpressionId] = []
}

private struct _CrossSellDefaultOffArgs: Codable, Hashable {
    var productId: String
    var price: Price?
}

final class CrossSellDefaultOff: FeatureProtocol {
    static let name = "CrossSellDefaultOff"

    var isActive = true

    var impressionIds: [ImpressionId] {
        get {
            self._outputs.impressionIds
        }
        set {
            self._outputs.impressionIds = newValue
        }
    }

    // MARK: Arguments
    private var _args: _CrossSellDefaultOffArgs

    /// The locationid for the source product in an item based collaborative filter
    var productId: String {
        self._args.productId
    }
    var price: Price? {
        self._args.price
    }

    // MARK: Outputs
    private var _outputs: _CrossSellDefaultOffOutputs = _CrossSellDefaultOffOutputs()

    var baseOnly: String {
        self._outputs.baseOnly
    }
    var customerData: CustomerData {
        self._outputs.customerData
    }
    var crosssellProductids: [String] {
        self._outputs.crosssellProductids
    }

    // MARK: Init

    init(productId: String, price: Price? = nil) {
        self._args = _CrossSellDefaultOffArgs(productId: productId, price: price)
    }

    private init(args: _CrossSellDefaultOffArgs) {
        self._args = args
    }

    // MARK: FeatureProtocol

    var id: FeatureId {
        generateIdFrom(name: "CrossSellDefaultOff", args: self._args)
    }

    func args() throws -> JSONObject {
        try encodeObject(self._args)
    }

    func updateFrom(json: JSONObject) throws {
        self._outputs = try decodeObject(from: json, to: _CrossSellDefaultOffOutputs.self)
    }

    func copy(newImpressionId: ImpressionId) -> CrossSellDefaultOff {
        let copy = CrossSellDefaultOff(args: self._args)
        copy._outputs = self._outputs
        copy.isActive = self.isActive
        copy.impressionIds = [newImpressionId]
        return copy
    }
}

extension CrossSellDefaultOff: Equatable {
    public static func == (left: CrossSellDefaultOff, right: CrossSellDefaultOff) -> Bool {
        left.isActive == right.isActive
        && left._args == right._args
        && left._outputs == right._outputs
    }
}

// MARK: CrossSellDefaultOff Events

// MARK: - CrossSellClick
extension CrossSellDefaultOff {
    struct CrossSellClick: EventProtocol {
        /// The name of the feature for which this event is associated.
        public static let featureName = "CrossSellDefaultOff"

        /// The name of this event.
        public static let name = "CrossSellClick"

        var productid: String

        func serialized() throws -> JSONObject {
            let json = try encodeObject(self)
            return json
        }
    }

    func signalAndWaitCrossSellClick(client: CausalClient = .shared, productid: String) async throws {
        let event = CrossSellClick(productid: productid)
        try await client.signalAndWait(
            event: event,
            impressionId: self.impressionIds.first ?? ""
        )
    }

    func signalCrossSellClick(productid: String) {
        let event = CrossSellClick(productid: productid)
        CausalClient.shared.signalEvent(
            event,
            impressionId: self.impressionIds.first ?? ""
        )
    }
}

// MARK: - CrossSellDefaultOff View Model

final class CrossSellDefaultOffViewModel: ObservableObject, FeatureViewModel {
    @Published var feature: CrossSellDefaultOff?

    // MARK: Arguments

    let productId: String
    let price: Price?
    let impressionId: ImpressionId

    // MARK: Init

    init(productId: String, price: Price? = nil, impressionId: ImpressionId = .newId()) {
        self.productId = productId
        self.price = price
        self.impressionId = impressionId
    }

    // MARK: Feature request

    @MainActor
    func requestFeature() async throws {
        let _feature = CrossSellDefaultOff(productId: self.productId, price: self.price)
        _feature.impressionIds = [self.impressionId]

        do {
            self.feature = try await CausalClient.shared.requestFeature(
                feature: _feature,
                impressionId: self.impressionId
            )
        } catch {
            self.feature = _feature
            throw error
        }
    }

    // MARK: Events

    func signalCrossSellClick(productid: String, onError: ((Error) -> Void)? = nil) {
        Task {
            do {
                try await self.feature?.signalAndWaitCrossSellClick(productid: productid)
            } catch {
                onError?(error)
            }
        }
    }
}

// MARK: - Test

private struct _TestOutputs: Codable, Hashable {
    var obj1Out: TopLevelObject = TopLevelObject(float1: 1.0, float2: nil, enum1: .PRIMARY, enum2: nil, string1: "ABC", string2: nil, int1: 1, int2: nil, nested1: NestedObject(float1: 11.0, int1: -1), nested2: nil)
    var obj2Out: TopLevelObject? = nil
    var float1Out: Double = 1.0
    var float2Out: Double? = nil
    var enum1Out: Color = .PRIMARY
    var enum2Out: Color? = nil
    var string1Out: String = ""
    var string2Out: String? = nil
    var int1Out: Int = 0
    var int2Out: Int? = nil
    var impressionIds: [ImpressionId] = []
}

private struct _TestArgs: Codable, Hashable {
    var obj1: TopLevelObject
    var obj2: TopLevelObject?
    var obj3: TopLevelObject?
    var float1: Double
    var float2: Double?
    var enum1: Color
    var enum2: Color?
    var string1: String
    var string2: String?
    var int1: Int
    var int2: Int?
}

final class Test: FeatureProtocol {
    static let name = "Test"

    var isActive = true

    var impressionIds: [ImpressionId] {
        get {
            self._outputs.impressionIds
        }
        set {
            self._outputs.impressionIds = newValue
        }
    }

    // MARK: Arguments
    private var _args: _TestArgs

    var obj1: TopLevelObject {
        self._args.obj1
    }
    var obj2: TopLevelObject? {
        self._args.obj2
    }
    var obj3: TopLevelObject? {
        self._args.obj3
    }
    var float1: Double {
        self._args.float1
    }
    var float2: Double? {
        self._args.float2
    }
    var enum1: Color {
        self._args.enum1
    }
    var enum2: Color? {
        self._args.enum2
    }
    var string1: String {
        self._args.string1
    }
    var string2: String? {
        self._args.string2
    }
    var int1: Int {
        self._args.int1
    }
    var int2: Int? {
        self._args.int2
    }

    // MARK: Outputs
    private var _outputs: _TestOutputs = _TestOutputs()

    var obj1Out: TopLevelObject {
        self._outputs.obj1Out
    }
    var obj2Out: TopLevelObject? {
        self._outputs.obj2Out
    }
    var float1Out: Double {
        self._outputs.float1Out
    }
    var float2Out: Double? {
        self._outputs.float2Out
    }
    var enum1Out: Color {
        self._outputs.enum1Out
    }
    var enum2Out: Color? {
        self._outputs.enum2Out
    }
    var string1Out: String {
        self._outputs.string1Out
    }
    var string2Out: String? {
        self._outputs.string2Out
    }
    var int1Out: Int {
        self._outputs.int1Out
    }
    var int2Out: Int? {
        self._outputs.int2Out
    }

    // MARK: Init

    init(obj1: TopLevelObject, obj2: TopLevelObject? = nil, obj3: TopLevelObject? = TopLevelObject(float1: 2.0, float2: nil, enum1: .SECONDARY, enum2: nil, string1: "FOO", string2: nil, int1: 4, int2: nil, nested1: NestedObject(float1: 3.0, int1: 7), nested2: nil), float1: Double = 0.0, float2: Double? = nil, enum1: Color = .PRIMARY, enum2: Color? = nil, string1: String = "", string2: String? = nil, int1: Int = 0, int2: Int? = nil) {
        self._args = _TestArgs(obj1: obj1, obj2: obj2, obj3: obj3, float1: float1, float2: float2, enum1: enum1, enum2: enum2, string1: string1, string2: string2, int1: int1, int2: int2)
    }

    private init(args: _TestArgs) {
        self._args = args
    }

    // MARK: FeatureProtocol

    var id: FeatureId {
        generateIdFrom(name: "Test", args: self._args)
    }

    func args() throws -> JSONObject {
        try encodeObject(self._args)
    }

    func updateFrom(json: JSONObject) throws {
        self._outputs = try decodeObject(from: json, to: _TestOutputs.self)
    }

    func copy(newImpressionId: ImpressionId) -> Test {
        let copy = Test(args: self._args)
        copy._outputs = self._outputs
        copy.isActive = self.isActive
        copy.impressionIds = [newImpressionId]
        return copy
    }
}

extension Test: Equatable {
    public static func == (left: Test, right: Test) -> Bool {
        left.isActive == right.isActive
        && left._args == right._args
        && left._outputs == right._outputs
    }
}

// MARK: Test Events

// MARK: - Click
extension Test {
    struct Click: EventProtocol {
        /// The name of the feature for which this event is associated.
        public static let featureName = "Test"

        /// The name of this event.
        public static let name = "Click"

        var obj1: TopLevelObject

        var obj2: TopLevelObject?

        var float1: Double

        var float2: Double?

        var enum1: Color

        var enum2: Color?

        var string1: String

        var string2: String?

        var int1: Int

        var int2: Int?

        func serialized() throws -> JSONObject {
            let json = try encodeObject(self)
            return json
        }
    }

    func signalAndWaitClick(client: CausalClient = .shared, obj1: TopLevelObject, obj2: TopLevelObject?, float1: Double = 0.0, float2: Double?, enum1: Color = .PRIMARY, enum2: Color?, string1: String = "", string2: String?, int1: Int = 0, int2: Int?) async throws {
        let event = Click(obj1: obj1, obj2: obj2, float1: float1, float2: float2, enum1: enum1, enum2: enum2, string1: string1, string2: string2, int1: int1, int2: int2)
        try await client.signalAndWait(
            event: event,
            impressionId: self.impressionIds.first ?? ""
        )
    }

    func signalClick(obj1: TopLevelObject, obj2: TopLevelObject?, float1: Double = 0.0, float2: Double?, enum1: Color = .PRIMARY, enum2: Color?, string1: String = "", string2: String?, int1: Int = 0, int2: Int?) {
        let event = Click(obj1: obj1, obj2: obj2, float1: float1, float2: float2, enum1: enum1, enum2: enum2, string1: string1, string2: string2, int1: int1, int2: int2)
        CausalClient.shared.signalEvent(
            event,
            impressionId: self.impressionIds.first ?? ""
        )
    }
}

// MARK: - Test View Model

final class TestViewModel: ObservableObject, FeatureViewModel {
    @Published var feature: Test?

    // MARK: Arguments

    let obj1: TopLevelObject
    let obj2: TopLevelObject?
    let obj3: TopLevelObject?
    let float1: Double
    let float2: Double?
    let enum1: Color
    let enum2: Color?
    let string1: String
    let string2: String?
    let int1: Int
    let int2: Int?
    let impressionId: ImpressionId

    // MARK: Init

    init(obj1: TopLevelObject, obj2: TopLevelObject? = nil, obj3: TopLevelObject? = TopLevelObject(float1: 2.0, float2: nil, enum1: .SECONDARY, enum2: nil, string1: "FOO", string2: nil, int1: 4, int2: nil, nested1: NestedObject(float1: 3.0, int1: 7), nested2: nil), float1: Double = 0.0, float2: Double? = nil, enum1: Color = .PRIMARY, enum2: Color? = nil, string1: String = "", string2: String? = nil, int1: Int = 0, int2: Int? = nil, impressionId: ImpressionId = .newId()) {
        self.obj1 = obj1
        self.obj2 = obj2
        self.obj3 = obj3
        self.float1 = float1
        self.float2 = float2
        self.enum1 = enum1
        self.enum2 = enum2
        self.string1 = string1
        self.string2 = string2
        self.int1 = int1
        self.int2 = int2
        self.impressionId = impressionId
    }

    // MARK: Feature request

    @MainActor
    func requestFeature() async throws {
        let _feature = Test(obj1: self.obj1, obj2: self.obj2, obj3: self.obj3, float1: self.float1, float2: self.float2, enum1: self.enum1, enum2: self.enum2, string1: self.string1, string2: self.string2, int1: self.int1, int2: self.int2)
        _feature.impressionIds = [self.impressionId]

        do {
            self.feature = try await CausalClient.shared.requestFeature(
                feature: _feature,
                impressionId: self.impressionId
            )
        } catch {
            self.feature = _feature
            throw error
        }
    }

    // MARK: Events

    func signalClick(obj1: TopLevelObject, obj2: TopLevelObject?, float1: Double = 0.0, float2: Double?, enum1: Color = .PRIMARY, enum2: Color?, string1: String = "", string2: String?, int1: Int = 0, int2: Int?, onError: ((Error) -> Void)? = nil) {
        Task {
            do {
                try await self.feature?.signalAndWaitClick(obj1: obj1, obj2: obj2, float1: float1, float2: float2, enum1: enum1, enum2: enum2, string1: string1, string2: string2, int1: int1, int2: int2)
            } catch {
                onError?(error)
            }
        }
    }
}

// MARK: - BaseFeature1

private struct _BaseFeature1Outputs: Codable, Hashable {
    var out1: String = ""
    var out2: Int = 0
    var impressionIds: [ImpressionId] = []
}

private struct _BaseFeature1Args: Codable, Hashable {
    var arg1: String
    var arg2: Int
}

// MARK: - DerivedFeature

private struct _DerivedFeatureOutputs: Codable, Hashable {
    var out1: String = ""
    var out2: Int = 0
    var impressionIds: [ImpressionId] = []
}

private struct _DerivedFeatureArgs: Codable, Hashable {
    var arg1: String
    var arg2: Int
}

final class DerivedFeature: FeatureProtocol {
    static let name = "DerivedFeature"

    var isActive = true

    var impressionIds: [ImpressionId] {
        get {
            self._outputs.impressionIds
        }
        set {
            self._outputs.impressionIds = newValue
        }
    }

    // MARK: Arguments
    private var _args: _DerivedFeatureArgs

    var arg1: String {
        self._args.arg1
    }
    var arg2: Int {
        self._args.arg2
    }

    // MARK: Outputs
    private var _outputs: _DerivedFeatureOutputs = _DerivedFeatureOutputs()

    var out1: String {
        self._outputs.out1
    }
    var out2: Int {
        self._outputs.out2
    }

    // MARK: Init

    init(arg1: String, arg2: Int) {
        self._args = _DerivedFeatureArgs(arg1: arg1, arg2: arg2)
    }

    private init(args: _DerivedFeatureArgs) {
        self._args = args
    }

    // MARK: FeatureProtocol

    var id: FeatureId {
        generateIdFrom(name: "DerivedFeature", args: self._args)
    }

    func args() throws -> JSONObject {
        try encodeObject(self._args)
    }

    func updateFrom(json: JSONObject) throws {
        self._outputs = try decodeObject(from: json, to: _DerivedFeatureOutputs.self)
    }

    func copy(newImpressionId: ImpressionId) -> DerivedFeature {
        let copy = DerivedFeature(args: self._args)
        copy._outputs = self._outputs
        copy.isActive = self.isActive
        copy.impressionIds = [newImpressionId]
        return copy
    }
}

extension DerivedFeature: Equatable {
    public static func == (left: DerivedFeature, right: DerivedFeature) -> Bool {
        left.isActive == right.isActive
        && left._args == right._args
        && left._outputs == right._outputs
    }
}

// MARK: DerivedFeature Events


// MARK: - DerivedFeature View Model

final class DerivedFeatureViewModel: ObservableObject, FeatureViewModel {
    @Published var feature: DerivedFeature?

    // MARK: Arguments

    let arg1: String
    let arg2: Int
    let impressionId: ImpressionId

    // MARK: Init

    init(arg1: String, arg2: Int, impressionId: ImpressionId = .newId()) {
        self.arg1 = arg1
        self.arg2 = arg2
        self.impressionId = impressionId
    }

    // MARK: Feature request

    @MainActor
    func requestFeature() async throws {
        let _feature = DerivedFeature(arg1: self.arg1, arg2: self.arg2)
        _feature.impressionIds = [self.impressionId]

        do {
            self.feature = try await CausalClient.shared.requestFeature(
                feature: _feature,
                impressionId: self.impressionId
            )
        } catch {
            self.feature = _feature
            throw error
        }
    }

    // MARK: Events

}

// MARK: - WithSameNameOutput

private struct _WithSameNameOutputOutputs: Codable, Hashable {
    var Color: Color? = .PRIMARY
    var impressionIds: [ImpressionId] = []
}

private struct _WithSameNameOutputArgs: Codable, Hashable {
}

final class WithSameNameOutput: FeatureProtocol {
    static let name = "WithSameNameOutput"

    var isActive = true

    var impressionIds: [ImpressionId] {
        get {
            self._outputs.impressionIds
        }
        set {
            self._outputs.impressionIds = newValue
        }
    }

    // MARK: Arguments
    private var _args: _WithSameNameOutputArgs


    // MARK: Outputs
    private var _outputs: _WithSameNameOutputOutputs = _WithSameNameOutputOutputs()

    var Color: Color? {
        self._outputs.Color
    }

    // MARK: Init

    init() {
        self._args = _WithSameNameOutputArgs()
    }

    private init(args: _WithSameNameOutputArgs) {
        self._args = args
    }

    // MARK: FeatureProtocol

    var id: FeatureId {
        generateIdFrom(name: "WithSameNameOutput", args: self._args)
    }

    func args() throws -> JSONObject {
        try encodeObject(self._args)
    }

    func updateFrom(json: JSONObject) throws {
        self._outputs = try decodeObject(from: json, to: _WithSameNameOutputOutputs.self)
    }

    func copy(newImpressionId: ImpressionId) -> WithSameNameOutput {
        let copy = WithSameNameOutput(args: self._args)
        copy._outputs = self._outputs
        copy.isActive = self.isActive
        copy.impressionIds = [newImpressionId]
        return copy
    }
}

extension WithSameNameOutput: Equatable {
    public static func == (left: WithSameNameOutput, right: WithSameNameOutput) -> Bool {
        left.isActive == right.isActive
        && left._args == right._args
        && left._outputs == right._outputs
    }
}

// MARK: WithSameNameOutput Events


// MARK: - WithSameNameOutput View Model

final class WithSameNameOutputViewModel: ObservableObject, FeatureViewModel {
    @Published var feature: WithSameNameOutput?

    // MARK: Arguments

    let impressionId: ImpressionId

    // MARK: Init

    init(impressionId: ImpressionId = .newId()) {
        self.impressionId = impressionId
    }

    // MARK: Feature request

    @MainActor
    func requestFeature() async throws {
        let _feature = WithSameNameOutput()
        _feature.impressionIds = [self.impressionId]

        do {
            self.feature = try await CausalClient.shared.requestFeature(
                feature: _feature,
                impressionId: self.impressionId
            )
        } catch {
            self.feature = _feature
            throw error
        }
    }

    // MARK: Events

}


// swiftformat:enable all
// swiftlint:enable all
